---
phase: 02-event-capture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/events/buffer.ts
  - src/events/buffer.test.ts
autonomous: true
must_haves:
  truths:
    - Events are buffered in memory before writing to disk
    - Buffer flushes automatically based on size and time thresholds
    - Buffer flushes synchronously on session end
    - No data loss when session ends
  artifacts:
    - path: src/events/buffer.ts
      provides: EventBuffer class with add/flush/clear methods
      exports: ["EventBuffer", "createBuffer"]
      min_lines: 80
    - path: src/events/buffer.test.ts
      provides: Unit tests for buffer functionality
  key_links:
    - from: EventBuffer.add()
      to: storage.write()
      via: flush() method
      pattern: storage.write.*batch
---

<objective>
Create event buffering infrastructure for batched writes to SQLite.

Purpose: Writing to SQLite on every event causes performance degradation. Buffering events in memory and flushing in batches reduces I/O overhead by 10-100x.

Output: EventBuffer class with configurable thresholds and automatic flush logic.
</objective>

<execution_context>
@/Users/buddythacat/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/buddythacat/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-event-capture/02-RESEARCH.md
@.planning/phases/01-foundation/01-01-SUMMARY.md

## Current State

Phase 1 delivered synchronous SQLite storage via bun:sqlite in src/storage/sqlite-storage.ts.

The plugin at src/plugin.ts has event handler stubs ready for Phase 2 implementation.

## Key Constraints

1. bun:sqlite uses SYNCHRONOUS API - no async/await for storage operations
2. WAL mode handles concurrency automatically
3. Event handlers must never throw errors (graceful degradation)
</context>

<tasks>

<task type="auto">
  <name>Create EventBuffer class</name>
  <files>src/events/buffer.ts</files>
  <action>
Create src/events/buffer.ts with EventBuffer class implementing:

1. Buffer Configuration Interface:
   - maxSize: number (default 50 entries)
   - flushIntervalMs: number (default 5000ms)
   - onFlush: callback function receiving MemoryEntry[]

2. Buffer State:
   - entries: MemoryEntry[] (in-memory array)
   - lastFlush: number (timestamp)
   - timer: Timer | null (setInterval reference)
   - isFlushing: boolean (prevent concurrent flushes)

3. Methods:
   - add(entry: MemoryEntry): void - Add to buffer, trigger flush if needed
   - flush(): void - Write all entries to storage via onFlush callback, clear buffer
   - clear(): void - Clear buffer without flushing
   - start(): void - Start periodic flush timer
   - stop(): void - Stop timer, flush remaining entries
   - size(): number - Current buffer size

4. Auto-flush Triggers:
   - Buffer reaches maxSize → immediate flush
   - flushIntervalMs elapsed → periodic flush
   - stop() called (session end) → force flush

5. Error Handling:
   - Never throw from flush()
   - Log errors to console.error
   - Continue operation even if single flush fails
   - Prevent concurrent flushes with isFlushing flag

6. Bun-Specific:
   - Use synchronous patterns throughout
   - Timer with setInterval/clearInterval
   - Date.now() for timestamps
  </action>
  <verify>
npm run typecheck passes
  </verify>
  <done>
EventBuffer class exists with all methods implemented, no TypeScript errors
  </done>
</task>

<task type="auto">
  <name>Create buffer unit tests</name>
  <files>src/events/buffer.test.ts</files>
  <action>
Create src/events/buffer.test.ts with comprehensive tests:

1. Setup: Import { describe, it, expect } from "bun:test"

2. Test Cases:
   - "creates buffer with defaults" - verify default config values
   - "adds entry to buffer" - add one entry, check size is 1
   - "flushes when maxSize reached" - add 50 entries, verify onFlush called with 50 entries
   - "flushes on interval" - start timer, wait 5.1s, verify flush called
   - "stops and flushes remaining" - add 10 entries, call stop(), verify flush with 10 entries
   - "clears buffer without flush" - add entries, call clear(), verify onFlush not called
   - "prevents concurrent flushes" - rapid adds should not trigger overlapping flushes
   - "handles flush errors gracefully" - onFlush throws, verify error logged, buffer continues
   - "size() returns correct count" - add 5 entries, expect size() === 5

3. Mock onFlush callback to capture flushed entries

4. Use fake timers or actual setTimeout for interval tests (bun:test supports both)
  </action>
  <verify>
npx bun test src/events/buffer.test.ts passes all tests
  </verify>
  <done>
All 8+ tests passing, 100% coverage of buffer functionality
  </done>
</task>

<task type="auto">
  <name>Performance benchmark test</name>
  <files>src/events/buffer.test.ts</files>
  <action>
Add performance benchmark test to buffer.test.ts:

1. "performance: 1000 events under threshold" test:
   - Create buffer with no-op onFlush
   - const start = performance.now()
   - for (let i = 0; i < 1000; i++) buffer.add(createMockEntry())
   - const elapsed = performance.now() - start
   - console.log(`1000 buffered adds: ${elapsed.toFixed(2)}ms`)
   - expect(elapsed).toBeLessThan(100) // Should be <0.1ms per event

2. "performance: batch flush under threshold" test:
   - Track flush call times
   - Add 50 entries to trigger flush
   - Verify flush takes <50ms for 50 entries

3. Document benchmark results in test output
  </action>
  <verify>
npx bun test src/events/buffer.test.ts shows performance metrics
  </verify>
  <done>
Performance benchmarks pass with <0.1ms per event, <50ms per batch flush
  </done>
</task>

</tasks>

<verification>
- [ ] EventBuffer class created with all required methods
- [ ] All unit tests passing (8+ tests)
- [ ] Performance benchmarks meet targets (<0.1ms per event)
- [ ] TypeScript typecheck passes
- [ ] No lint errors
</verification>

<success_criteria>
Event buffering infrastructure ready for integration with event handlers. Buffer can hold events in memory, flush in batches, and handle session end gracefully.
</success_criteria>

<output>
After completion, create `.planning/phases/02-event-capture/02-01-SUMMARY.md`
</output>
