---
phase: 02-event-capture
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - src/events/tool-capture.ts
  - src/events/tool-capture.test.ts
  - src/plugin.ts
autonomous: true
must_haves:
  truths:
    - Tool executions are captured to mind.mv2
    - Tool args are sanitized before storage
    - Different tool types map to different observation types
    - Buffer is used for batched writes
    - No errors from tool capture crash Opencode
  artifacts:
    - path: src/events/tool-capture.ts
      provides: Tool event capture logic
      exports: ["captureToolExecution", "determineObservationType"]
      min_lines: 80
    - path: src/events/tool-capture.test.ts
      provides: Unit tests for tool capture
    - path: src/plugin.ts
      provides: Integrated tool.execute.after handler
      changes: "Replace stub with actual capture logic"
  key_links:
    - from: tool.execute.after handler
      to: EventBuffer.add()
      via: captureToolExecution function
      pattern: buffer\.add\(entry\)
    - from: captureToolExecution
      to: sanitizeContent
      via: filter.ts import
      pattern: sanitizeContent\(.*args.*\)
---

<objective>
Implement tool execution capture in the plugin's tool.execute.after handler.

Purpose: CAPT-01 requires capturing tool.execute.after events. This plan integrates the buffer and privacy filter to capture tool usage safely and efficiently.

Output: Working tool event capture with privacy filtering and batched writes.
</objective>

<execution_context>
@/Users/buddythacat/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/buddythacat/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/REQUIREMENTS.md
@.planning/phases/02-event-capture/02-RESEARCH.md
@.planning/phases/01-foundation/01-02-SUMMARY.md
@src/plugin.ts
@src/storage/storage-interface.ts

## Current State

The plugin at src/plugin.ts has a stub handler:
```typescript
"tool.execute.after": async (input) => {
  if (config.debug) {
    console.log(`[opencode-brain] Tool executed: ${input.tool}`, ...);
  }
  // Stub for Phase 2: Event capture
}
```

Input data available:
- tool: string (tool name: read, write, edit, bash, search, etc.)
- sessionID: string
- callID: string
- args?: Record<string, any> (tool arguments)

## Dependencies (Wave 1)

- 02-01: EventBuffer class ready in src/events/buffer.ts
- 02-02: Privacy filter ready in src/privacy/filter.ts
</context>

<tasks>

<task type="auto">
  <name>Create tool capture module</name>
  <files>src/events/tool-capture.ts</files>
  <action>
Create src/events/tool-capture.ts with tool event capture logic:

1. Imports:
   - import { MemoryEntry } from "../storage/storage-interface.js";
   - import { EventBuffer } from "./buffer.js";
   - import { sanitizeContent, sanitizeBashCommand } from "../privacy/filter.js";
   - import { ObservationType } from "../types.js";

2. Interface ToolExecuteInput:
   - tool: string
   - sessionID: string
   - callID: string
   - args?: Record<string, unknown>

3. determineObservationType(tool: string): ObservationType:
   - Map tool names to observation types:
     - "search" → "discovery"
     - "read", "glob" → "discovery"
     - "write" → "solution"
     - "edit" → "refactor"
     - "bash" → "solution"
     - "ask" → "discovery"
     - default → "pattern"

4. extractFilesFromArgs(args: Record<string, unknown>): string[]:
   - Extract file paths from common arg patterns:
     - args.filePath, args.path, args.file
     - args.files (array)
     - args.oldString/args.newString (from edit tool) → try to extract file from context
   - Filter out non-string values
   - Return array of file paths (may be empty)

5. formatToolContent(tool: string, args: Record<string, unknown>): string:
   - Create human-readable summary:
     - read: "Read file: {filePath}"
     - write: "Wrote file: {filePath}"
     - edit: "Edited file: {filePath}"
     - bash: "Executed: {command}"
     - search: "Searched: {pattern}"
     - default: "Used {tool} tool"
   - Include relevant args in description
   - Sanitize using privacy filter

6. captureToolExecution(input: ToolExecuteInput, buffer: EventBuffer): void:
   - Determine if content needs special handling:
     - If tool === "bash" → use sanitizeBashCommand on args.command
     - Otherwise → use sanitizeContent on formatted string
   - Create MemoryEntry:
     - id: crypto.randomUUID() (or use callID if unique)
     - type: determineObservationType(input.tool)
     - content: sanitized content
     - createdAt: Date.now()
     - metadata: {
         sessionId: input.sessionID,
         tool: input.tool,
         summary: `${input.tool} executed`,
         files: extractFilesFromArgs(input.args || {}),
       }
   - Add to buffer: buffer.add(entry)
   - Error handling: try/catch around entire function, log to console.error on failure

7. Export all functions for testing
  </action>
  <verify>
npm run typecheck passes
  </verify>
  <done>
Tool capture module created with all functions implemented
  </done>
</task>

<task type="auto">
  <name>Create tool capture unit tests</name>
  <files>src/events/tool-capture.test.ts</files>
  <action>
Create src/events/tool-capture.test.ts with tests:

1. Setup:
   - Import { describe, it, expect } from "bun:test"
   - Import functions from tool-capture.ts
   - Import { EventBuffer } from "./buffer.js"
   - Mock buffer with captured entries array

2. determineObservationType tests:
   - "maps search to discovery"
   - "maps read to discovery"
   - "maps write to solution"
   - "maps edit to refactor"
   - "maps bash to solution"
   - "maps unknown to pattern"

3. extractFilesFromArgs tests:
   - "extracts filePath from args"
   - "extracts path from args"
   - "extracts multiple files from array"
   - "returns empty array for no files"
   - "filters non-string values"

4. formatToolContent tests:
   - "formats read tool" - includes file path
   - "formats write tool" - includes file path
   - "formats bash tool" - includes command
   - "formats search tool" - includes pattern
   - "handles missing args" - graceful with empty args

5. captureToolExecution integration tests:
   - "adds entry to buffer for read tool" - verify buffer receives entry
   - "sanitizes bash commands" - test with "curl -u user:pass"
   - "sets correct observation type" - verify type field
   - "includes session ID in metadata" - verify metadata.sessionId
   - "includes tool name in metadata" - verify metadata.tool
   - "handles errors gracefully" - test with invalid input, verify no throw

6. Privacy integration tests:
   - "redacts passwords in tool output" - verify [REDACTED] in content
   - "skips sensitive bash commands" - verify special handling

7. Edge cases:
   - "handles undefined args" - null safety
   - "handles null sessionID" - graceful handling
   - "handles very long content" - truncation if needed
  </action>
  <verify>
npx bun test src/events/tool-capture.test.ts passes all tests
  </verify>
  <done>
15+ tests passing, covering tool capture logic and privacy integration
  </done>
</task>

<task type="auto">
  <name>Integrate tool capture into plugin</name>
  <files>src/plugin.ts</files>
  <action>
Update src/plugin.ts to integrate tool event capture:

1. Add imports at top:
   - import { EventBuffer } from "./events/buffer.js";
   - import { captureToolExecution } from "./events/tool-capture.js";

2. After storage initialization, create event buffer:
   ```typescript
   const eventBuffer = new EventBuffer({
     maxSize: 50,
     flushIntervalMs: 5000,
     onFlush: (entries) => {
       // Batch write to storage
       for (const entry of entries) {
         try {
           storage.write(entry.id, entry);
         } catch (error) {
           console.error("[opencode-brain] Failed to write memory:", error);
         }
       }
       if (config.debug) {
         console.log(`[opencode-brain] Flushed ${entries.length} memories`);
       }
     },
   });
   
   // Start the buffer
   eventBuffer.start();
   ```

3. Update "tool.execute.after" handler:
   Replace the stub implementation with:
   ```typescript
   "tool.execute.after": async (input) => {
     if (config.debug) {
       console.log(
         `[opencode-brain] Tool executed: ${input.tool}`,
         input.args ? Object.keys(input.args) : "no args"
       );
     }
     
     try {
       captureToolExecution(input, eventBuffer);
     } catch (error) {
       console.error(
         "[opencode-brain] Failed to capture tool execution:",
         error instanceof Error ? error.message : String(error)
       );
       // Never throw - keep Opencode running
     }
   },
   ```

4. Update "session.deleted" handler to flush buffer:
   ```typescript
   "session.deleted": async () => {
     if (config.debug) {
       console.log("[opencode-brain] Session ended, flushing buffer and closing storage");
     }
     
     // Stop buffer (flushes remaining entries)
     try {
       eventBuffer.stop();
     } catch (error) {
       console.error("[opencode-brain] Error stopping buffer:", error);
     }
     
     // Close storage
     try {
       storage.close();
     } catch (error) {
       console.error("[opencode-brain] Error closing storage:", error);
     }
   },
   ```

5. Ensure TypeScript types are correct for all new code
  </action>
  <verify>
npm run typecheck passes
npx bun test src/plugin.test.ts 2>/dev/null || echo "No plugin tests yet"
  </verify>
  <done>
Plugin updated with tool event capture, buffer integrated, session cleanup with flush
  </done>
</task>

</tasks>

<verification>
- [ ] Tool capture module created
- [ ] 15+ unit tests passing
- [ ] Plugin integrated with buffer and tool capture
- [ ] Tool events write to buffer → storage
- [ ] Privacy filtering applied to tool content
- [ ] Session end flushes buffer
- [ ] No errors crash Opencode
- [ ] TypeScript typecheck passes
</verification>

<success_criteria>
Tool execution events are captured, filtered for privacy, buffered, and written to mind.mv2. The plugin now captures significant tool usage without performance impact.
</success_criteria>

<output>
After completion, create `.planning/phases/02-event-capture/02-03-SUMMARY.md`
</output>
