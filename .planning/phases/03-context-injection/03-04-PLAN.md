---
phase: 03-context-injection
plan: 04
type: execute
wave: 1
depends_on: [03-01]
files_modified: [src/context/compacting.ts, src/context/compacting.test.ts]
autonomous: true

must_haves:
  truths:
    - "session.compacting event triggers custom compaction logic"
    - "Compaction reduces context size intelligently"
    - "Important observations preserved during compaction"
    - "Compaction is conservative by default"
  artifacts:
    - path: "src/context/compacting.ts"
      provides: "Session compacting handler for INJ-06"
      exports: ["handleSessionCompacting", "CompactionStrategy"]
    - path: "src/context/compacting.test.ts"
      provides: "Unit tests for compacting"
  key_links:
    - from: "src/context/compacting.ts"
      to: "src/context/selection.ts"
      via: "import calculateRelevanceScore"
      pattern: "import.*calculateRelevanceScore"
---

<objective>
Implement session.compacting hook handler for custom compaction context (INJ-06).

Purpose: When Opencode triggers session.compacting (during long conversations), we need to intelligently compress the context while preserving important information.

Output: Working compacting handler that reduces context size without losing critical information.
</objective>

<execution_context>
@/Users/buddythacat/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/buddythacat/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@src/context/selection.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create compacting handler module</name>
  <files>src/context/compacting.ts</files>
  <action>
    Create src/context/compacting.ts with:
    
    1. CompactionStrategy type:
       - mode: "conservative" | "aggressive"
       - targetTokenCount: number (default: 1000)
       - preserveTypes: ObservationType[] (types to always keep)
    
    2. handleSessionCompacting(observations[], strategy) function:
       - Parameters:
         - observations: Observation[] (current context observations)
         - strategy: CompactionStrategy
       
       - Flow:
         1. Calculate current token count
         2. If under targetTokenCount â†’ return as-is
         3. Score all observations using calculateRelevanceScore
         4. Sort by score descending
         5. Conservative mode:
            - Always keep: decision, problem, warning, success
            - Remove lowest-scored other types first
            - Stop when under targetTokenCount
         6. Aggressive mode:
            - Remove lowest-scored regardless of type
            - Summarize removed items into 1-2 line summary
            - Stop when under targetTokenCount
         7. Return compacted observations[]
    
    3. summarizeRemovedObservations(removed[]) function:
       - Create brief summary of what was removed
       - "[N] older observations summarized: [key topics]"
       - Extract keywords from removed items
    
    4. Default strategy constant:
       - CONSERVATIVE_STRATEGY: { mode: "conservative", targetTokenCount: 1000, preserveTypes: ["decision", "problem", "warning"] }
    
    5. Import:
       - import { calculateRelevanceScore } from "./selection.js"
       - import type { Observation, ObservationType } from "../types.js"
    
    6. Error handling:
       - Try/catch around all operations
       - On error: return original observations (fail safe)
       - Never throw from compacting handler
  </action>
  <verify>
    npx tsc --noEmit src/context/compacting.ts
  </verify>
  <done>
    TypeScript compiles without errors, exports all required functions
  </done>
</task>

<task type="auto">
  <name>Task 2: Create compacting tests</name>
  <files>src/context/compacting.test.ts</files>
  <action>
    Create src/context/compacting.test.ts with tests:
    
    1. Test no compaction needed (under target):
       - Input 5 observations under token limit
       - Verify all returned unchanged
    
    2. Test conservative compaction:
       - Input 20 observations over limit
       - Verify decision/problem/warning types preserved
       - Verify lowest-scored others removed first
       - Verify result under targetTokenCount
    
    3. Test aggressive compaction:
       - Input 20 observations over limit
       - Verify removes regardless of type
       - Verify summary of removed items included
    
    4. Test preservation of important types:
       - Include mix of all observation types
       - Verify conservative mode preserves specified types
    
    5. Test error handling:
       - Mock calculateRelevanceScore to throw
       - Verify returns original observations (no throw)
    
    6. Test token counting:
       - Verify accurate token estimation
       - Verify compaction stops at right threshold
    
    Follow vitest patterns from other test files.
  </action>
  <verify>
    npm test src/context/compacting.test.ts
  </verify>
  <done>
    All tests pass (6+ test cases)
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Tests pass: `npm test src/context/compacting.test.ts`
3. Conservative mode preserves important types
4. Aggressive mode includes summary of removed items
</verification>

<success_criteria>
- [ ] handleSessionCompacting() reduces context size intelligently
- [ ] Conservative mode preserves decision/problem/warning types
- [ ] Aggressive mode summarizes removed observations
- [ ] Compaction respects targetTokenCount
- [ ] Graceful error handling (returns original on error)
- [ ] All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-context-injection/03-04-SUMMARY.md`
</output>
