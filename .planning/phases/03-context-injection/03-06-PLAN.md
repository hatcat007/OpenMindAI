---
phase: 03-context-injection
plan: 06
type: execute
wave: 2
depends_on: [03-05]
files_modified: [src/types.ts, src/events/tool-capture.ts, src/events/file-capture.ts, src/context/selection.ts]
autonomous: true

must_haves:
  truths:
    - "Agent type (plan/build) tracked on every observation"
    - "Unified memory approach - same context for both agents"
    - "Agent type stored in observation metadata"
    - "Selection algorithm uses agent type for relevance scoring"
  artifacts:
    - path: "src/types.ts"
      provides: "Updated types with agentType"
      contains: ["agentType?: 'plan' | 'build'"]
    - path: "src/events/tool-capture.ts"
      provides: "Tool capture with agent type"
      contains: ["agentType in metadata"]
    - path: "src/events/file-capture.ts"
      provides: "File capture with agent type"
      contains: ["agentType in metadata"]
  key_links:
    - from: "src/events/tool-capture.ts"
      to: "src/types.ts::ObservationMetadata"
      via: "agentType in metadata"
      pattern: "metadata:.*agentType"
    - from: "src/context/selection.ts"
      to: "src/types.ts::agentType"
      via: "agent match scoring (20%)"
      pattern: "options.agentType"
---

<objective>
Implement agent type tracking for unified memory approach (INJ-04).

Purpose: Track whether the current agent is Plan or Build type, storing this in observation metadata. This enables the selection algorithm to prioritize context relevant to the current agent type.

Output: Updated types and capture modules with agent type tracking throughout the system.
</objective>

<execution_context>
@/Users/buddythacat/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/buddythacat/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@src/types.ts
@src/events/tool-capture.ts
@src/events/file-capture.ts
@src/context/selection.ts
@src/plugin.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update types.ts with agentType</name>
  <files>src/types.ts</files>
  <action>
    Update src/types.ts to add agent type tracking:
    
    1. Add AgentType type:
       ```typescript
       /** Agent type for context relevance */
       export type AgentType = "plan" | "build";
       ```
    
    2. Update ObservationMetadata interface:
       Add to existing interface:
       ```typescript
       export interface ObservationMetadata {
         files?: string[];
         functions?: string[];
         error?: string;
         confidence?: number;
         tags?: string[];
         sessionId?: string;
         agentType?: AgentType;  // <-- ADD THIS
         [key: string]: unknown;
       }
       ```
    
    3. Update MindConfig interface:
       Add configuration for agent handling:
       ```typescript
       export interface MindConfig {
         memoryPath: string;
         maxContextObservations: number;
         maxContextTokens: number;
         autoCompress: boolean;
         minConfidence: number;
         debug: boolean;
         defaultAgentType?: AgentType;  // <-- ADD THIS (default: "build")
       }
       ```
    
    4. Update DEFAULT_CONFIG:
       ```typescript
       export const DEFAULT_CONFIG: MindConfig = {
         memoryPath: ".claude/mind.mv2",
         maxContextObservations: 20,
         maxContextTokens: 2000,
         autoCompress: true,
         minConfidence: 0.6,
         debug: false,
         defaultAgentType: "build",  // <-- ADD THIS
       };
       ```
    
    5. Update InjectedContext interface (if needed):
       Add agent type that was used for injection:
       ```typescript
       export interface InjectedContext {
         recentObservations: Observation[];
         relevantMemories: Observation[];
         sessionSummaries: SessionSummary[];
         tokenCount: number;
         agentType?: AgentType;  // <-- ADD THIS
       }
       ```
    
    6. Verify all type exports are present.
  </action>
  <verify>
    npx tsc --noEmit src/types.ts
  </verify>
  <done>
    TypeScript compiles, AgentType type and metadata field present
  </done>
</task>

<task type="auto">
  <name>Task 2: Update tool-capture.ts with agent type</name>
  <files>src/events/tool-capture.ts</files>
  <action>
    Update src/events/tool-capture.ts to include agentType:
    
    1. Add agentType to ToolExecuteInput interface:
       ```typescript
       export interface ToolExecuteInput {
         tool: string;
         sessionID: string;
         callID: string;
         args?: Record<string, unknown>;
         agentType?: AgentType;  // <-- ADD THIS
       }
       ```
    
    2. Update captureToolExecution function:
       - Accept agentType in input
       - Include agentType in metadata when creating MemoryEntry:
         ```typescript
         const entry: MemoryEntry = {
           id: input.callID || crypto.randomUUID(),
           type: observationType,
           content: sanitizedContent,
           createdAt: Date.now(),
           metadata: {
             sessionId: input.sessionID,
             tool: input.tool,
             summary: `${input.tool} executed`,
             files: files.length > 0 ? files : undefined,
             agentType: input.agentType,  // <-- ADD THIS
           },
         };
         ```
    
    3. Import AgentType:
       ```typescript
       import type { ObservationType, AgentType } from "../types.js";
       ```
    
    4. Update any test files if they exist (tool-capture.test.ts).
  </action>
  <verify>
    npx tsc --noEmit src/events/tool-capture.ts
  </verify>
  <done>
    TypeScript compiles, agentType included in metadata
  </done>
</task>

<task type="auto">
  <name>Task 3: Update file-capture.ts with agent type</name>
  <files>src/events/file-capture.ts</files>
  <action>
    Read src/events/file-capture.ts first, then update:
    
    1. Add agentType parameter to captureFileEdit:
       ```typescript
       export function captureFileEdit(
         input: { filePath: string },
         buffer: EventBuffer,
         sessionId: string,
         agentType?: AgentType  // <-- ADD THIS
       ): void
       ```
    
    2. Include agentType in the MemoryEntry metadata when adding to buffer.
    
    3. Import AgentType from types.
    
    4. Update plugin.ts to pass agentType when calling captureFileEdit.
  </action>
  <verify>
    npx tsc --noEmit src/events/file-capture.ts
  </verify>
  <done>
    TypeScript compiles, agentType parameter present
  </done>
</task>

<task type="auto">
  <name>Task 4: Update selection.ts to use agentType</name>
  <files>src/context/selection.ts</files>
  <action>
    Verify and enhance src/context/selection.ts to use agentType:
    
    1. Ensure ContextSelectionOptions includes agentType:
       ```typescript
       export interface ContextSelectionOptions {
         agentType?: AgentType;
         maxObservations?: number;
         minConfidence?: number;
         mode?: "conservative" | "aggressive";
       }
       ```
    
    2. Ensure calculateRelevanceScore uses agentType:
       - In the scoring formula, check if entry.metadata?.agentType matches options.agentType
       - Agent match score: 1.0 if matches, 0.0 if different or undefined
       - Apply 20% weight to agent match
       
       ```typescript
       const agentMatch = entry.metadata?.agentType && options.agentType
         ? (entry.metadata.agentType === options.agentType ? 1.0 : 0.0)
         : 0.5; // Neutral if either undefined
       ```
    
    3. Import AgentType from types.
    
    4. Update tests to verify agent type scoring.
  </action>
  <verify>
    npm test src/context/selection.test.ts
  </verify>
  <done>
    All tests pass, agentType scoring verified
  </done>
</task>

<task type="auto">
  <name>Task 5: Update plugin.ts to pass agentType</name>
  <files>src/plugin.ts</files>
  <action>
    Update plugin.ts to pass agentType to capture functions:
    
    1. Determine agent type from context (for now, use config.defaultAgentType or detect from session):
       ```typescript
       const agentType: AgentType = config.defaultAgentType || "build";
       ```
    
    2. Update tool.execute.after handler:
       Pass agentType to captureToolExecution:
       ```typescript
       captureToolExecution(
         {
           tool: input.tool,
           sessionID: input.sessionID,
           callID: input.callID,
           args: input.args,
           agentType,  // <-- ADD THIS
         },
         eventBuffer
       );
       ```
    
    3. Update file.edited handler:
       Pass agentType to captureFileEdit:
       ```typescript
       captureFileEdit(
         { filePath: input.filePath },
         eventBuffer,
         currentSessionId,
         agentType  // <-- ADD THIS
       );
       ```
    
    4. Update loadAndInjectContext call to pass agentType:
       ```typescript
       const injectionResult = loadAndInjectContext(storage, {
         agentType,  // <-- Uses same agentType
         maxObservations: config.maxContextObservations,
         maxTokens: config.maxContextTokens,
         debug: config.debug,
       });
       ```
  </action>
  <verify>
    npx tsc --noEmit src/plugin.ts
  </verify>
  <done>
    TypeScript compiles, agentType passed to all capture functions
  </done>
</task>

</tasks>

<verification>
1. TypeScript compiles: `npx tsc --noEmit`
2. Tests pass: `npm test`
3. AgentType type exists in types.ts
4. agentType field in ObservationMetadata
5. capture functions accept and use agentType
6. selection algorithm uses agentType for scoring
</verification>

<success_criteria>
- [ ] AgentType type defined ('plan' | 'build')
- [ ] ObservationMetadata includes agentType field
- [ ] MindConfig includes defaultAgentType
- [ ] captureToolExecution includes agentType in metadata
- [ ] captureFileEdit accepts agentType parameter
- [ ] calculateRelevanceScore uses agentType (20% weight)
- [ ] plugin.ts passes agentType to all capture functions
- [ ] plugin.ts passes agentType to loadAndInjectContext
- [ ] All tests pass (including updated tests)
</success_criteria>

<output>
After completion, create `.planning/phases/03-context-injection/03-06-SUMMARY.md`
</output>
