---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "src/storage/storage-interface.ts",
  "src/storage/sqlite-storage.ts",
  "src/storage/file-lock.ts",
  "src/types.ts"
]
autonomous: true
must_haves:
  truths:
    - "Storage layer initializes without errors"
    - "Can write and read data from SQLite database"
    - "File locking prevents concurrent write corruption"
    - "Storage API matches @memvid/sdk surface for future migration"
    - "All operations work with Bun runtime"
  artifacts:
    - path: "src/storage/storage-interface.ts"
      provides: "Abstract storage interface matching @memvid/sdk API"
      min_lines: 50
      exports: ["StorageInterface", "StorageOptions"]
    - path: "src/storage/sqlite-storage.ts"
      provides: "SQLite-based storage implementation"
      min_lines: 150
      exports: ["SQLiteStorage", "createStorage"]
    - path: "src/storage/file-lock.ts"
      provides: "Bun-compatible file locking mechanism"
      min_lines: 80
      exports: ["FileLock", "acquireLock", "releaseLock"]
    - path: "src/types.ts"
      provides: "Core type definitions for memory entries"
      min_lines: 40
      exports: ["MemoryEntry", "Observation", "ObservationType"]
  key_links:
    - from: "src/storage/sqlite-storage.ts"
      to: "src/storage/file-lock.ts"
      via: "import and use for write operations"
      pattern: "FileLock|acquireLock|releaseLock"
    - from: "src/storage/sqlite-storage.ts"
      to: "src/storage/storage-interface.ts"
      via: "implements StorageInterface"
      pattern: "implements StorageInterface|extends.*Storage"
    - from: "src/storage/sqlite-storage.ts"
      to: "src/types.ts"
      via: "imports MemoryEntry type"
      pattern: "import.*MemoryEntry"
---

<objective>
Implement Bun-compatible storage layer to replace @memvid/sdk (which is incompatible with Bun).

Purpose: Storage is the foundational dependency for all other functionality. Without working storage, the plugin cannot persist memories.
Output: Complete storage layer with SQLite backend, file locking, and API compatibility with @memvid/sdk surface.
</objective>

<execution_context>
@/Users/buddythacat/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/buddythacat/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md

# Research Findings — Critical Constraint
@.planning/research/SUMMARY.md — CONFIRMED: @memvid/sdk NOT compatible with Bun due to crypto.createHash() incompatibility
@.planning/research/PITFALLS.md — Section "1. @memvid/sdk Bun Incompatibility" for workarounds
@.planning/research/STACK.md — Bun compatibility test results and recommended solutions

# Existing Codebase Reference
Look at existing src/types.ts and src/core/mind.ts patterns if they exist for type inspiration.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Storage Interface</name>
  <files>src/storage/storage-interface.ts, src/types.ts</files>
  <action>
    Create abstract storage interface that matches @memvid/sdk API surface for future migration compatibility.
    
    Interface must include:
    - `create(options: StorageOptions): Promise<StorageInterface>` — Factory function
    - `write(id: string, data: MemoryEntry): Promise<void>` — Store entry
    - `read(id: string): Promise<MemoryEntry | null>` — Retrieve entry
    - `search(query: string, limit?: number): Promise<MemoryEntry[]>` — Full-text search
    - `close(): Promise<void>` — Clean shutdown
    - `stats(): Promise<StorageStats>` — Return entry count, size, etc.
    
    Define StorageOptions interface with:
    - path: string (storage file location, e.g., ".opencode/mind.mv2")
    - maxSize?: number (optional size limit in bytes)
    - compression?: boolean (enable compression)
    
    Also define MemoryEntry type in src/types.ts:
    - id: string (UUID)
    - type: ObservationType ('tool', 'file', 'error', 'decision', 'context')
    - content: string
    - metadata: object (timestamp, sessionId, projectPath, etc.)
    - vector?: number[] (for future vector search)
    - createdAt: Date
    
    IMPORTANT: Design for Bun compatibility — avoid Node.js-specific APIs.
  </action>
  <verify>
    bun check src/storage/storage-interface.ts
    bun check src/types.ts
    Verify all types compile without errors
  </verify>
  <done>
    StorageInterface and MemoryEntry types are defined and TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SQLite Storage</name>
  <files>src/storage/sqlite-storage.ts</files>
  <action>
    Implement Bun-compatible SQLite storage layer.
    
    Use Bun's built-in SQLite support (bun:sqlite module):
    ```typescript
    import { Database } from "bun:sqlite";
    ```
    
    Implementation requirements:
    1. **Database Schema:**
       - Table: `memories` with columns:
         - id (TEXT PRIMARY KEY)
         - type (TEXT)
         - content (TEXT)
         - metadata (JSON)
         - vector (BLOB, nullable)
         - created_at (INTEGER, unix timestamp)
       - Index: idx_memories_type, idx_memories_created_at
       - Index: idx_memories_fts for full-text search (use SQLite FTS5 extension)
    
    2. **Constructor/Factory:**
       - `createStorage(options: StorageOptions): Promise<SQLiteStorage>`
       - Auto-create database file if missing
       - Auto-create tables and indices
       - Initialize with WAL mode for better concurrency
    
    3. **Methods:**
       - `write(id, data)`: Insert or replace, use file locking
       - `read(id)`: Select by ID, return null if not found
       - `search(query, limit=10)`: Use FTS5 MATCH, order by rank, return array
       - `stats()`: Return count(*), total size estimate, oldest/newest timestamps
       - `close()`: Close database connection
    
    4. **File Locking Integration:**
       - Import and use FileLock from file-lock.ts
       - Wrap write operations in lock
       - Handle lock acquisition failures gracefully (retry with backoff)
    
    5. **Error Handling:**
       - Silent fail pattern: Log errors but don't throw to prevent plugin crashes
       - Wrap all DB operations in try/catch
       - Return sensible defaults on failure (empty array, null, zero stats)
    
    IMPORTANT: All file operations must use Bun APIs (Bun.file, Bun.write, Database from bun:sqlite).
    DO NOT use Node.js fs module or @memvid/sdk.
  </action>
  <verify>
    bun test src/storage/sqlite-storage.test.ts (create test if needed)
    OR manual verification:
    bun run -e "
    const { createStorage } = await import('./src/storage/sqlite-storage.ts');
    const storage = await createStorage({ path: '/tmp/test-mind.mv2' });
    await storage.write('test-1', { id: 'test-1', type: 'tool', content: 'test content', metadata: {}, createdAt: new Date() });
    const result = await storage.read('test-1');
    console.log(result ? 'WRITE/READ WORKS' : 'FAILED');
    await storage.close();
    "
  </verify>
  <done>
    SQLite storage implementation works: can create database, write entries, read entries, search, and get stats using Bun runtime
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Bun-Compatible File Locking</name>
  <files>src/storage/file-lock.ts</files>
  <action>
    Implement file locking mechanism that works with Bun runtime.
    
    Options to consider (choose one):
    1. **Bun.lock approach:** Use atomic file operations
    2. **Lockfile approach:** Create/remove lock files with Bun.file()
    3. **SQLite WAL:** Rely on SQLite's built-in WAL mode for concurrency
    
    Recommended approach: SQLite WAL + simple advisory locking
    
    Implementation:
    ```typescript
    export class FileLock {
      private lockPath: string;
      private locked: boolean = false;
      
      constructor(storagePath: string) {
        this.lockPath = storagePath + '.lock';
      }
      
      async acquire(timeoutMs = 5000): Promise<boolean> {
        // Try to create lock file atomically
        // If exists, wait and retry with exponential backoff
        // Timeout after specified duration
        // Return true if acquired, false if timeout
      }
      
      async release(): Promise<void> {
        // Remove lock file
        // Set locked = false
      }
      
      // Convenience function for auto-release
      async withLock<T>(fn: () => Promise<T>): Promise<T | null> {
        if (await this.acquire()) {
          try {
            return await fn();
          } finally {
            await this.release();
          }
        }
        return null;
      }
    }
    ```
    
    Use Bun.file() and Bun.write() for lock file operations.
    Handle edge cases:
    - Stale locks (check timestamp, override if too old)
    - Crash recovery (clean up orphaned locks)
    - Cross-process safety (PID in lock file)
    
    Test that concurrent writes don't corrupt the database.
  </action>
  <verify>
    Manual test with concurrent writes:
    bun run -e "
    const { FileLock } = await import('./src/storage/file-lock.ts');
    const lock = new FileLock('/tmp/test-lock');
    const results = await Promise.all([
      lock.withLock(() => new Promise(r => setTimeout(() => r('A'), 100))),
      lock.withLock(() => new Promise(r => setTimeout(() => r('B'), 100))),
    ]);
    console.log('Both locks succeeded:', results.filter(Boolean).length === 2);
    "
  </verify>
  <done>
    File locking prevents concurrent write corruption; only one process can hold lock at a time
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. [ ] TypeScript compiles without errors: `bun check src/storage/*.ts`
2. [ ] Storage can be created: `createStorage({ path: '.opencode/mind.mv2' })`
3. [ ] Write and read operations work correctly
4. [ ] Search returns relevant results
5. [ ] File locking prevents corruption in concurrent scenarios
6. [ ] All code uses Bun-compatible APIs (no Node.js-specific imports)
</verification>

<success_criteria>
- Storage layer initializes without errors in Bun runtime
- Can write MemoryEntry and read it back with same data
- Search returns matching entries sorted by relevance
- File locking acquired/released correctly
- API surface matches @memvid/sdk for future migration
- Silent error handling doesn't crash plugin
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`

Include in SUMMARY:
- Storage interface design decisions
- SQLite schema and indices created
- File locking approach chosen
- Bun compatibility verification results
- Any deviations from planned approach
</output>
