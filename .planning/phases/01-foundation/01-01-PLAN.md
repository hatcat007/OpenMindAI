---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [
  "src/storage/storage-interface.ts",
  "src/storage/sqlite-storage.ts",
  "src/types.ts"
]
autonomous: true
must_haves:
  truths:
    - "Storage layer initializes without errors"
    - "Can write and read data from SQLite database"
    - "SQLite WAL mode handles concurrent access (no additional locking needed)"
    - "Storage API matches @memvid/sdk surface for future migration"
    - "All operations work with Bun runtime (synchronous API)"
    - "FTS5 search works on Linux/Windows, LIKE fallback on macOS"
  artifacts:
    - path: "src/storage/storage-interface.ts"
      provides: "Abstract storage interface matching @memvid/sdk API"
      min_lines: 50
      exports: ["StorageInterface", "StorageOptions"]
    - path: "src/storage/sqlite-storage.ts"
      provides: "SQLite-based storage implementation using bun:sqlite"
      min_lines: 150
      exports: ["BrainStorage", "createStorage"]
    - path: "src/types.ts"
      provides: "Core type definitions for memory entries"
      min_lines: 40
      exports: ["MemoryEntry", "Observation", "ObservationType"]
  key_links:
    - from: "src/storage/sqlite-storage.ts"
      to: "src/storage/storage-interface.ts"
      via: "implements StorageInterface"
      pattern: "implements StorageInterface|extends.*Storage"
    - from: "src/storage/sqlite-storage.ts"
      to: "src/types.ts"
      via: "imports MemoryEntry type"
      pattern: "import.*MemoryEntry"
---

<objective>
Implement Bun-compatible storage layer to replace @memvid/sdk (which is incompatible with Bun).

Purpose: Storage is the foundational dependency for all other functionality. Without working storage, the plugin cannot persist memories.
Output: Complete storage layer with SQLite backend, file locking, and API compatibility with @memvid/sdk surface.
</objective>

<execution_context>
@/Users/buddythacat/.config/opencode/get-shit-done/workflows/execute-plan.md
@/Users/buddythacat/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md

# Research Findings — Phase 1 Specific
@.planning/phases/01-foundation/01-RESEARCH.md — bun:sqlite API, WAL mode, FTS5 considerations

**Key Research Findings:**
- **bun:sqlite is SYNCHRONOUS** — 3-6x faster than better-sqlite3, zero dependencies
- **WAL mode handles concurrency** — SQLite allows unlimited readers + single writer automatically
- **No additional file locking needed** — Only add proper-lockfile if SQLITE_BUSY errors observed
- **FTS5 unavailable on macOS** — Implement runtime detection with LIKE fallback
- **Use bun:test** — Built-in Jest-compatible testing

# Existing Codebase Reference
Look at existing src/types.ts and src/core/mind.ts patterns if they exist for type inspiration.
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Storage Interface</name>
  <files>src/storage/storage-interface.ts, src/types.ts</files>
  <action>
    Create abstract storage interface that matches @memvid/sdk API surface for future migration compatibility.
    
    **CRITICAL:** bun:sqlite uses SYNCHRONOUS API (not async/await). Design interface accordingly.
    
    Interface must include:
    - `create(options: StorageOptions): StorageInterface` — Factory function (SYNCHRONOUS)
    - `write(id: string, data: MemoryEntry): void` — Store entry (SYNCHRONOUS)
    - `read(id: string): MemoryEntry | null` — Retrieve entry (SYNCHRONOUS)
    - `search(query: string, limit?: number): MemoryEntry[]` — Full-text search (SYNCHRONOUS)
    - `close(): void` — Clean shutdown (SYNCHRONOUS)
    - `stats(): StorageStats` — Return entry count, size, etc. (SYNCHRONOUS)
    
    Define StorageOptions interface with:
    - filePath: string (storage file location, e.g., ".opencode/mind.mv2")
    - create?: boolean (auto-create if missing, default: true)
    
    Also define MemoryEntry type in src/types.ts:
    - id: string (UUID)
    - type: ObservationType ('tool', 'file', 'error', 'decision', 'context')
    - content: string
    - metadata: object (timestamp, sessionId, projectPath, etc.)
    - createdAt: number (unix timestamp for SQLite compatibility)
    
    IMPORTANT: Design for Bun compatibility — avoid Node.js-specific APIs. Use bun:sqlite built-in module.
  </action>
  <verify>
    bun check src/storage/storage-interface.ts
    bun check src/types.ts
    Verify all types compile without errors
  </verify>
  <done>
    StorageInterface and MemoryEntry types are defined (synchronous API) and TypeScript compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Bun:SQLite Storage</name>
  <files>src/storage/sqlite-storage.ts</files>
  <action>
    Implement Bun-compatible SQLite storage layer using bun:sqlite (SYNCHRONOUS API).
    
    ```typescript
    import { Database } from "bun:sqlite";
    ```
    
    **CRITICAL:** bun:sqlite is SYNCHRONOUS - do NOT use async/await. Returns values directly, not Promises.
    
    Implementation requirements:
    1. **Database Schema:**
       - Table: `memories` with columns:
         - id (TEXT PRIMARY KEY)
         - type (TEXT)
         - content (TEXT NOT NULL)
         - metadata (TEXT, JSON serialized)
         - created_at (INTEGER, unixepoch())
         - session_id (TEXT, nullable)
       - Index: idx_memories_type, idx_memories_created_at, idx_memories_session
       - FTS5 virtual table `memories_fts` (with runtime detection - see #4)
    
    2. **Constructor/Factory (SYNCHRONOUS):**
       - `createStorage(options: StorageOptions): BrainStorage` — NOT async
       - Constructor: `new BrainStorage(filePath: string)`
       - Auto-create database with `new Database(filePath, { create: true })`
       - Initialize with WAL mode: `db.run("PRAGMA journal_mode = WAL")`
       - Set busy timeout: `db.run("PRAGMA busy_timeout = 5000")`
       - Auto-create tables and indices in constructor
    
    3. **Methods (ALL SYNCHRONOUS):**
       - `write(id: string, data: MemoryEntry): void` — Use prepared statement + transaction
       - `read(id: string): MemoryEntry | null` — Query with .get(), parse JSON
       - `search(query: string, limit=10): MemoryEntry[]` — See #4 for FTS5 vs LIKE
       - `stats(): StorageStats` — count(*), size estimate, min/max timestamps
       - `close(): void` — db.close()
    
    4. **FTS5 with macOS Fallback:**
       ```typescript
       private hasFTS5(): boolean {
         try {
           this.db.run("CREATE VIRTUAL TABLE _test_fts USING fts5(x)");
           this.db.run("DROP TABLE _test_fts");
           return true;
         } catch { return false; }
       }
       ```
       - In search(): Try FTS5 MATCH first, catch and fallback to LIKE
       - FTS5 query: `SELECT m.* FROM memories_fts fts JOIN memories m ON fts.rowid = m.rowid WHERE fts MATCH ?`
       - LIKE fallback: `SELECT * FROM memories WHERE content LIKE ?`
    
    5. **NO Additional File Locking Needed:**
       - SQLite WAL mode handles single-writer concurrency
       - Only add proper-lockfile if SQLITE_BUSY errors observed (unlikely)
       - WAL mode gives unlimited readers + single writer automatically
    
    6. **Error Handling:**
       - Silent fail pattern: console.error but don't throw
       - Return sensible defaults (empty array, null, zero stats)
       - Never crash the plugin
    
    Example usage:
    ```typescript
    const storage = createStorage({ filePath: ".opencode/mind.mv2" }); // Sync
    storage.write("id1", { type: "tool", content: "..." }); // Sync
    const result = storage.read("id1"); // Sync, returns directly
    ```
    
    IMPORTANT: Use ONLY bun:sqlite APIs. No Node.js fs, no @memvid/sdk.
  </action>
  <verify>
    Create test file and run:
    bun test src/storage/sqlite-storage.test.ts
    
    Test must verify:
    - Synchronous API works (no await needed)
    - Write and read roundtrip
    - Search finds matching content
    - FTS5 or LIKE fallback works
    - WAL mode enabled
  </verify>
  <done>
    Synchronous SQLite storage works: can create database, write/read entries, search with FTS5/LIKE fallback, all using Bun runtime
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. [ ] TypeScript compiles without errors: `bun check src/storage/*.ts`
2. [ ] Storage can be created synchronously: `createStorage({ filePath: '.opencode/mind.mv2' })`
3. [ ] Write and read operations work (SYNCHRONOUS - no await)
4. [ ] Search returns relevant results (FTS5 on Linux/Windows, LIKE on macOS)
5. [ ] WAL mode enabled: Check with `db.query("PRAGMA journal_mode").get()`
6. [ ] All code uses Bun-compatible APIs (bun:sqlite, no Node.js-specific imports)
7. [ ] Tests pass: `bun test src/storage/sqlite-storage.test.ts`
</verification>

<success_criteria>
- Storage layer initializes without errors in Bun runtime (synchronous)
- Can write MemoryEntry and read it back with same data (sync API)
- Search returns matching entries (FTS5 with LIKE fallback for macOS)
- WAL mode enabled for concurrent access (no additional locking needed)
- API surface matches @memvid/sdk for future migration (adapted for sync)
- Silent error handling doesn't crash plugin
- All operations are SYNCHRONOUS (bun:sqlite design)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`

Include in SUMMARY:
- Storage interface design decisions
- SQLite schema and indices created
- File locking approach chosen
- Bun compatibility verification results
- Any deviations from planned approach
</output>
