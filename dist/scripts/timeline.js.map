{"version":3,"sources":["../../src/scripts/utils.ts","../../src/scripts/timeline.ts"],"names":[],"mappings":"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","file":"timeline.js","sourcesContent":["/**\n * Shared utilities for Memvid Mind scripts\n */\n\nimport { existsSync, mkdirSync, unlinkSync, renameSync } from \"node:fs\";\nimport { dirname } from \"node:path\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype CreateFn = (path: string, kind: any) => Promise<any>;\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype UseFn = (kind: any, path: string) => Promise<any>;\n\n/**\n * Create a fresh memory file at the given path\n */\nexport async function createFreshMemory(\n  memoryPath: string,\n  create: CreateFn\n): Promise<void> {\n  const memoryDir = dirname(memoryPath);\n  mkdirSync(memoryDir, { recursive: true });\n  await create(memoryPath, \"basic\");\n}\n\n/**\n * Check if an error indicates a corrupted or incompatible memory file\n */\nexport function isCorruptedMemoryError(error: unknown): boolean {\n  const errorMessage =\n    error instanceof Error ? error.message : String(error);\n  return (\n    errorMessage.includes(\"Deserialization\") ||\n    errorMessage.includes(\"UnexpectedVariant\") ||\n    errorMessage.includes(\"Invalid\") ||\n    errorMessage.includes(\"corrupt\") ||\n    errorMessage.includes(\"version mismatch\")\n  );\n}\n\n/**\n * Handle corrupted memory file by backing it up and creating a fresh one\n */\nexport async function handleCorruptedMemory(\n  memoryPath: string,\n  create: CreateFn\n): Promise<void> {\n  console.log(\n    \"‚ö†Ô∏è  Memory file is corrupted or incompatible. Creating fresh memory...\"\n  );\n  // Backup corrupted file\n  const backupPath = `${memoryPath}.backup-${Date.now()}`;\n  try {\n    renameSync(memoryPath, backupPath);\n    console.log(`   Old file backed up to: ${backupPath}`);\n  } catch {\n    try {\n      unlinkSync(memoryPath);\n    } catch {\n      // Ignore unlink errors\n    }\n  }\n  await createFreshMemory(memoryPath, create);\n}\n\n/**\n * Open a memory file, handling corruption by creating fresh memory if needed\n * Returns the opened memvid instance, or null if memory was recreated (caller should exit)\n */\nexport async function openMemorySafely(\n  memoryPath: string,\n  use: UseFn,\n  create: CreateFn\n): Promise<{ memvid: unknown; isNew: boolean }> {\n  // Auto-create if doesn't exist\n  if (!existsSync(memoryPath)) {\n    console.log(\"No memory file found. Creating new memory at:\", memoryPath);\n    await createFreshMemory(memoryPath, create);\n    return { memvid: null, isNew: true };\n  }\n\n  // Try to open, handle corrupted files\n  try {\n    const memvid = await use(\"basic\", memoryPath);\n    return { memvid, isNew: false };\n  } catch (openError: unknown) {\n    if (isCorruptedMemoryError(openError)) {\n      await handleCorruptedMemory(memoryPath, create);\n      return { memvid: null, isNew: true };\n    }\n    // Re-throw other errors\n    throw openError;\n  }\n}\n","#!/usr/bin/env node\n/**\n * Memvid Mind - Timeline Script\n *\n * View recent memories using the SDK (no CLI dependency)\n */\n\nimport { resolve } from \"node:path\";\nimport { openMemorySafely } from \"./utils\";\n\n// Dynamic import for SDK\nasync function loadSDK() {\n  return await import(\"@memvid/sdk\");\n}\n\nasync function main() {\n  const args = process.argv.slice(2);\n  const limit = parseInt(args[0] || \"10\", 10);\n\n  // Get memory file path\n  const projectDir = process.env.CLAUDE_PROJECT_DIR || process.cwd();\n  const memoryPath = resolve(projectDir, \".claude/mind.mv2\");\n\n  // Load SDK dynamically\n  const { use, create } = await loadSDK();\n\n  // Open memory safely (handles corrupted files)\n  const { memvid, isNew } = await openMemorySafely(memoryPath, use, create);\n\n  if (isNew || !memvid) {\n    console.log(\"‚úÖ Memory initialized! No memories to show yet.\\n\");\n    process.exit(0);\n  }\n\n  try {\n    const mv = memvid as any;\n    const timeline = await mv.timeline({ limit, reverse: true });\n\n    // SDK returns array directly or { frames: [...] }\n    const frames = Array.isArray(timeline) ? timeline : timeline.frames || [];\n\n    if (frames.length === 0) {\n      console.log(\"No memories yet. Start using Claude to build your memory!\");\n      process.exit(0);\n    }\n\n    console.log(`Recent ${frames.length} memories:\\n`);\n\n    for (let i = 0; i < frames.length; i++) {\n      const frame = frames[i];\n      const preview = frame.preview || \"\";\n      const uri = frame.uri || `frame/${frame.frame_id}`;\n      const timestamp = frame.timestamp\n        ? new Date(frame.timestamp * 1000).toLocaleString()\n        : \"Unknown time\";\n      const snippet = preview.slice(0, 100).replace(/\\n/g, \" \");\n\n      console.log(`#${i + 1} ${uri}`);\n      console.log(`   üìÖ ${timestamp}`);\n      console.log(`   ${snippet}${snippet.length >= 100 ? \"...\" : \"\"}`);\n      console.log();\n    }\n  } catch (error) {\n    console.error(\"Error reading timeline:\", error);\n    process.exit(1);\n  }\n}\n\nmain();\n"]}