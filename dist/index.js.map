{"version":3,"sources":["../src/storage/sqlite-storage.ts","../src/config.ts","../src/events/buffer.ts","../src/privacy/filter.ts","../src/events/tool-capture.ts","../src/events/file-capture.ts","../src/events/error-capture.ts","../src/plugin.ts","../src/index.ts"],"sourcesContent":["/**\n * Bun SQLite Storage Implementation\n *\n * Bun-compatible storage layer using bun:sqlite.\n * SYNCHRONOUS API - bun:sqlite returns values directly, not Promises.\n *\n * Features:\n * - WAL mode for concurrent access (no additional locking needed)\n * - FTS5 full-text search with macOS LIKE fallback\n * - Bun-compatible synchronous API\n * - Silent error handling (never crashes the plugin)\n */\n\nimport { Database } from \"bun:sqlite\";\nimport type {\n  StorageInterface,\n  StorageOptions,\n  StorageStats,\n  MemoryEntry,\n  MemoryMetadata,\n} from \"./storage-interface.js\";\nimport type { ObservationType } from \"../types.js\";\n\n/**\n * SQLite-based storage implementation for Bun runtime\n *\n * All methods are SYNCHRONOUS - bun:sqlite uses synchronous API.\n */\nexport class BrainStorage implements StorageInterface {\n  private db: Database;\n  private filePath: string;\n  private fts5Available: boolean;\n\n  /**\n   * Create a new storage instance\n   * @param filePath - Path to SQLite database file\n   */\n  constructor(filePath: string) {\n    this.filePath = filePath;\n\n    // Open database with creation enabled\n    this.db = new Database(filePath, { create: true });\n\n    // Enable WAL mode for concurrent access\n    this.db.run(\"PRAGMA journal_mode = WAL\");\n    this.db.run(\"PRAGMA busy_timeout = 5000\");\n\n    // Check FTS5 availability\n    this.fts5Available = this.checkFTS5Availability();\n\n    // Initialize schema\n    this.initializeSchema();\n  }\n\n  /**\n   * Check if FTS5 is available (not available on macOS by default)\n   */\n  private checkFTS5Availability(): boolean {\n    try {\n      // Try to create a test FTS5 table\n      this.db.run(\"CREATE VIRTUAL TABLE IF NOT EXISTS _fts5_test USING fts5(x)\");\n      this.db.run(\"DROP TABLE IF EXISTS _fts5_test\");\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Initialize database schema\n   */\n  private initializeSchema(): void {\n    // Main memories table\n    this.db.run(`\n      CREATE TABLE IF NOT EXISTS memories (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        content TEXT NOT NULL,\n        metadata TEXT NOT NULL,\n        created_at INTEGER NOT NULL,\n        session_id TEXT\n      )\n    `);\n\n    // Indices for efficient querying\n    this.db.run(`\n      CREATE INDEX IF NOT EXISTS idx_memories_type ON memories(type)\n    `);\n    this.db.run(`\n      CREATE INDEX IF NOT EXISTS idx_memories_created_at ON memories(created_at)\n    `);\n    this.db.run(`\n      CREATE INDEX IF NOT EXISTS idx_memories_session ON memories(session_id)\n    `);\n\n    // FTS5 virtual table for full-text search (if available)\n    if (this.fts5Available) {\n      this.db.run(`\n        CREATE VIRTUAL TABLE IF NOT EXISTS memories_fts USING fts5(\n          content,\n          content_rowid='rowid'\n        )\n      `);\n    }\n  }\n\n  /**\n   * Store a memory entry (SYNCHRONOUS)\n   * @param id - Unique identifier\n   * @param data - Memory entry data\n   */\n  write(id: string, data: MemoryEntry): void {\n    try {\n      const stmt = this.db.prepare(`\n        INSERT OR REPLACE INTO memories\n        (id, type, content, metadata, created_at, session_id)\n        VALUES (?, ?, ?, ?, ?, ?)\n      `);\n\n      stmt.run(\n        id,\n        data.type,\n        data.content,\n        JSON.stringify(data.metadata),\n        data.createdAt,\n        data.metadata?.sessionId || null\n      );\n      stmt.finalize();\n\n      // Update FTS5 index if available\n      if (this.fts5Available) {\n        try {\n          const rowId = this.db\n            .query(\"SELECT rowid FROM memories WHERE id = ?\")\n            .get(id) as { rowid: number } | null;\n\n          if (rowId) {\n            const ftsStmt = this.db.prepare(`\n              INSERT OR REPLACE INTO memories_fts (rowid, content)\n              VALUES (?, ?)\n            `);\n            ftsStmt.run(rowId.rowid, data.content);\n            ftsStmt.finalize();\n          }\n        } catch (ftsError) {\n          // Silent fail for FTS5 errors\n          console.error(\"FTS5 index update failed:\", ftsError);\n        }\n      }\n    } catch (error) {\n      // Silent fail - log but don't crash\n      console.error(\"Storage write failed:\", error);\n    }\n  }\n\n  /**\n   * Retrieve a memory entry by ID (SYNCHRONOUS)\n   * @param id - Unique identifier\n   * @returns Memory entry or null if not found\n   */\n  read(id: string): MemoryEntry | null {\n    try {\n      const row = this.db\n        .query(\"SELECT * FROM memories WHERE id = ?\")\n        .get(id) as DatabaseRow | null;\n\n      if (!row) {\n        return null;\n      }\n\n      return this.rowToMemoryEntry(row);\n    } catch (error) {\n      console.error(\"Storage read failed:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Search memory entries (SYNCHRONOUS)\n   * @param query - Search query string\n   * @param limit - Maximum results (default: 10)\n   * @returns Array of matching entries\n   */\n  search(query: string, limit = 10): MemoryEntry[] {\n    try {\n      if (this.fts5Available) {\n        return this.searchFTS5(query, limit);\n      } else {\n        return this.searchLIKE(query, limit);\n      }\n    } catch (error) {\n      console.error(\"Storage search failed:\", error);\n      return [];\n    }\n  }\n\n  /**\n   * Search using FTS5 (Linux/Windows)\n   */\n  private searchFTS5(query: string, limit: number): MemoryEntry[] {\n    try {\n      const stmt = this.db.prepare(`\n        SELECT m.* FROM memories m\n        JOIN memories_fts fts ON fts.rowid = m.rowid\n        WHERE fts MATCH ?\n        ORDER BY rank\n        LIMIT ?\n      `);\n\n      const rows = stmt.all(query, limit) as DatabaseRow[];\n      stmt.finalize();\n\n      return rows.map((row) => this.rowToMemoryEntry(row));\n    } catch {\n      // Fallback to LIKE if FTS5 fails\n      return this.searchLIKE(query, limit);\n    }\n  }\n\n  /**\n   * Search using LIKE (macOS fallback)\n   */\n  private searchLIKE(query: string, limit: number): MemoryEntry[] {\n    const likePattern = `%${query.replace(/%/g, \"\\\\%\").replace(/_/g, \"\\\\_\")}%`;\n\n    const stmt = this.db.prepare(`\n      SELECT * FROM memories\n      WHERE content LIKE ?\n      ORDER BY created_at DESC\n      LIMIT ?\n    `);\n\n    const rows = stmt.all(likePattern, limit) as DatabaseRow[];\n    stmt.finalize();\n\n    return rows.map((row) => this.rowToMemoryEntry(row));\n  }\n\n  /**\n   * Get storage statistics (SYNCHRONOUS)\n   * @returns Storage statistics\n   */\n  stats(): StorageStats {\n    try {\n      const countRow = this.db\n        .query(\"SELECT COUNT(*) as count FROM memories\")\n        .get() as { count: number } | null;\n\n      const timeRange = this.db\n        .query(\"SELECT MIN(created_at) as oldest, MAX(created_at) as newest FROM memories\")\n        .get() as { oldest: number | null; newest: number | null } | null;\n\n      const typeCounts = this.db\n        .query(\"SELECT type, COUNT(*) as count FROM memories GROUP BY type\")\n        .all() as { type: string; count: number }[];\n\n      const byType: Record<string, number> = {};\n      for (const { type, count } of typeCounts) {\n        byType[type] = count;\n      }\n\n      // Estimate size based on SQLite page count\n      let sizeBytes = 0;\n      try {\n        const pageCount = this.db\n          .query(\"PRAGMA page_count\")\n          .get() as { \"page_count\": number } | null;\n        const pageSize = this.db\n          .query(\"PRAGMA page_size\")\n          .get() as { \"page_size\": number } | null;\n\n        if (pageCount && pageSize) {\n          sizeBytes = pageCount[\"page_count\"] * pageSize[\"page_size\"];\n        }\n      } catch {\n        // Size estimation is not critical\n      }\n\n      return {\n        count: countRow?.count || 0,\n        sizeBytes,\n        oldestEntry: timeRange?.oldest || undefined,\n        newestEntry: timeRange?.newest || undefined,\n        byType,\n      };\n    } catch (error) {\n      console.error(\"Storage stats failed:\", error);\n      return {\n        count: 0,\n        sizeBytes: 0,\n        byType: {},\n      };\n    }\n  }\n\n  /**\n   * Close storage connection (SYNCHRONOUS)\n   */\n  close(): void {\n    try {\n      this.db.close();\n    } catch (error) {\n      console.error(\"Storage close failed:\", error);\n    }\n  }\n\n  /**\n   * Convert database row to MemoryEntry\n   */\n  private rowToMemoryEntry(row: DatabaseRow): MemoryEntry {\n    let metadata: MemoryMetadata;\n    try {\n      metadata = JSON.parse(row.metadata) as MemoryMetadata;\n    } catch {\n      metadata = {};\n    }\n\n    return {\n      id: row.id,\n      type: row.type as ObservationType,\n      content: row.content,\n      createdAt: row.created_at,\n      metadata: {\n        ...metadata,\n        sessionId: row.session_id || metadata.sessionId,\n      },\n    };\n  }\n\n  /**\n   * Check if WAL mode is enabled\n   */\n  isWALModeEnabled(): boolean {\n    try {\n      const result = this.db\n        .query(\"PRAGMA journal_mode\")\n        .get() as { journal_mode: string } | null;\n      return result?.journal_mode === \"wal\";\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if FTS5 is available\n   */\n  isFTS5Available(): boolean {\n    return this.fts5Available;\n  }\n\n  /**\n   * Get the storage file path\n   */\n  getFilePath(): string {\n    return this.filePath;\n  }\n}\n\n/**\n * Database row type\n */\ninterface DatabaseRow {\n  id: string;\n  type: string;\n  content: string;\n  metadata: string;\n  created_at: number;\n  session_id: string | null;\n  rowid?: number;\n}\n\n/**\n * Factory function to create storage instance\n * @param options - Storage options\n * @returns StorageInterface instance\n */\nexport function createStorage(options: StorageOptions): StorageInterface {\n  return new BrainStorage(options.filePath);\n}\n","/**\n * Plugin Configuration Module\n *\n * Configuration management for the Opencode Brain plugin.\n * Handles user config loading, defaults merging, and path resolution.\n *\n * Hybrid approach:\n * 1. Reads from opencode.json file directly (not via SDK)\n * 2. Environment variables override file config\n * 3. Sensible defaults for everything else\n *\n * @module config\n */\n\nimport { join } from \"node:path\";\nimport { mkdirSync, readFileSync } from \"node:fs\";\n\n/**\n * Plugin configuration options\n */\nexport interface PluginConfig {\n  /** Storage file path (relative to worktree or absolute) */\n  storagePath?: string;\n  /** Auto-initialize storage on first run (default: true) */\n  autoInitialize?: boolean;\n  /** Enable debug logging (default: false) */\n  debug?: boolean;\n}\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Required<PluginConfig> = {\n  storagePath: \".opencode/mind.mv2\",\n  autoInitialize: true,\n  debug: false,\n};\n\n/**\n * Load plugin configuration from opencode.json file\n *\n * Merges: defaults < opencode.json < environment variables\n *\n * @param directory - Project directory path\n * @returns Merged configuration with all values populated\n */\nexport function loadConfig(directory: string): Required<PluginConfig> {\n  // 1. Start with defaults\n  let config: Required<PluginConfig> = { ...DEFAULT_CONFIG };\n\n  // 2. Override from opencode.json if it exists\n  try {\n    const configPath = join(directory, \"opencode.json\");\n    const fileContent = readFileSync(configPath, \"utf-8\");\n    const opencodeConfig = JSON.parse(fileContent) as Record<string, unknown>;\n    \n    // Extract opencode-brain specific config\n    const pluginConfig = opencodeConfig[\"opencode-brain\"] as PluginConfig | undefined;\n    if (pluginConfig) {\n      config = {\n        ...config,\n        ...pluginConfig,\n      };\n    }\n  } catch {\n    // File doesn't exist or is invalid JSON - use defaults\n  }\n\n  // 3. Environment variable overrides\n  if (process.env.OPENCODE_BRAIN_STORAGE_PATH) {\n    config.storagePath = process.env.OPENCODE_BRAIN_STORAGE_PATH;\n  }\n\n  if (process.env.OPENCODE_BRAIN_DEBUG) {\n    config.debug = process.env.OPENCODE_BRAIN_DEBUG === \"true\";\n  }\n\n  if (process.env.OPENCODE_BRAIN_AUTO_INIT) {\n    config.autoInitialize = process.env.OPENCODE_BRAIN_AUTO_INIT !== \"false\";\n  }\n\n  return config;\n}\n\n/**\n * Resolve storage path to absolute path\n *\n * If relative path provided, resolves relative to worktree or directory.\n * Ensures parent directory exists.\n *\n * @param worktree - Project worktree path (from Opencode)\n * @param config - Plugin configuration\n * @returns Absolute path to storage file\n *\n * @example\n * ```typescript\n * const path = getStoragePath('/my/project', { storagePath: '.opencode/mind.mv2' });\n * // Returns: '/my/project/.opencode/mind.mv2'\n * ```\n */\nexport function getStoragePath(worktree: string, config: PluginConfig): string {\n  const storagePath = config.storagePath || DEFAULT_CONFIG.storagePath;\n\n  // If already absolute, use as-is\n  if (storagePath.startsWith(\"/\")) {\n    ensureDirectory(storagePath);\n    return storagePath;\n  }\n\n  // Resolve relative to worktree\n  const absolutePath = join(worktree, storagePath);\n  ensureDirectory(absolutePath);\n\n  return absolutePath;\n}\n\n/**\n * Ensure parent directory exists for a file path\n *\n * Creates parent directories recursively if missing.\n * Silent fail if directory already exists or can't be created.\n *\n * @param filePath - Path to file (directories will be created)\n *\n * @example\n * ```typescript\n * ensureDirectory('/path/to/file.txt');\n * // Creates /path/to/ if it doesn't exist\n * ```\n */\nexport function ensureDirectory(filePath: string): void {\n  try {\n    const parentDir = filePath.includes(\"/\")\n      ? filePath.slice(0, filePath.lastIndexOf(\"/\"))\n      : \".\";\n\n    if (parentDir && parentDir !== \".\") {\n      mkdirSync(parentDir, { recursive: true });\n    }\n  } catch (error) {\n    // Silent fail - directory may already exist or be created by another process\n    // This is non-critical, the database creation will fail later if truly broken\n  }\n}\n","/**\n * Event Buffer - In-memory buffering for batched writes\n *\n * Buffers MemoryEntry objects in memory and flushes to storage in batches.\n * Reduces I/O overhead by 10-100x compared to per-event writes.\n *\n * Bun-specific: Uses synchronous patterns throughout.\n */\n\nimport type { MemoryEntry } from \"../storage/storage-interface.js\";\n\n/**\n * Configuration for event buffer\n */\nexport interface BufferConfig {\n  /** Maximum buffer size before auto-flush (default: 50) */\n  maxSize: number;\n  /** Flush interval in milliseconds (default: 5000) */\n  flushIntervalMs: number;\n  /** Callback function called when buffer flushes */\n  onFlush: (entries: MemoryEntry[]) => void;\n}\n\n/**\n * Default buffer configuration\n */\nexport const DEFAULT_BUFFER_CONFIG: BufferConfig = {\n  maxSize: 50,\n  flushIntervalMs: 5000,\n  onFlush: () => {\n    // No-op default - must be provided by caller\n  },\n};\n\n/**\n * Event buffer interface\n */\nexport interface IEventBuffer {\n  add(entry: MemoryEntry): void;\n  flush(): void;\n  clear(): void;\n  start(): void;\n  stop(options?: { flushRemaining?: boolean }): void;\n  size(): number;\n  getLastFlushTime(): number;\n  isFlushInProgress(): boolean;\n}\n\n/**\n * Create an in-memory event buffer with automatic batch flushing\n *\n * Features:\n * - Configurable size and time-based flush thresholds\n * - Prevents concurrent flushes with isFlushing flag\n * - Graceful error handling (never throws)\n * - Synchronous API for Bun compatibility\n *\n * @param config - Buffer configuration (partial, defaults applied)\n * @returns Event buffer instance\n *\n * @example\n * ```typescript\n * const buffer = createEventBuffer({\n *   maxSize: 50,\n *   flushIntervalMs: 5000,\n *   onFlush: (entries) => {\n *     entries.forEach(entry => storage.write(entry.id, entry));\n *   }\n * });\n * buffer.start();\n * ```\n */\nexport function createEventBuffer(config?: Partial<BufferConfig>): IEventBuffer {\n  const fullConfig = {\n    ...DEFAULT_BUFFER_CONFIG,\n    ...config,\n  };\n\n  // Validate onFlush is provided\n  if (!fullConfig.onFlush || fullConfig.onFlush === DEFAULT_BUFFER_CONFIG.onFlush) {\n    console.error(\"[EventBuffer] Warning: onFlush callback not provided\");\n  }\n\n  // Internal state\n  let entries: MemoryEntry[] = [];\n  let lastFlush = Date.now();\n  let timer: Timer | null = null;\n  let isFlushing = false;\n\n  return {\n    /**\n     * Add an entry to the buffer\n     * Triggers flush if buffer reaches maxSize\n     */\n    add(entry: MemoryEntry): void {\n      entries.push(entry);\n\n      // Auto-flush when max size reached\n      if (entries.length >= fullConfig.maxSize) {\n        this.flush();\n      }\n    },\n\n    /**\n     * Flush all buffered entries to storage\n     * Clears buffer after successful flush\n     * Never throws - errors are logged to console.error\n     */\n    flush(): void {\n      // Prevent concurrent flushes\n      if (isFlushing) {\n        return;\n      }\n\n      // Skip if buffer is empty\n      if (entries.length === 0) {\n        return;\n      }\n\n      isFlushing = true;\n\n      try {\n        // Capture entries to flush\n        const entriesToFlush = [...entries];\n\n        // Clear buffer before calling onFlush (in case onFlush throws)\n        entries = [];\n\n        // Call flush callback (synchronous)\n        fullConfig.onFlush(entriesToFlush);\n\n        // Update last flush timestamp\n        lastFlush = Date.now();\n      } catch (error) {\n        // Log error but never throw - graceful degradation\n        console.error(\n          \"[EventBuffer] Flush error:\",\n          error instanceof Error ? error.message : String(error)\n        );\n\n        // Restore entries that weren't flushed (they were cleared before the error)\n        // This ensures no data loss, though it may cause duplicates\n        // In production, onFlush should be reliable (storage.write is synchronous)\n        entries = [...entries, ...entries];\n      } finally {\n        isFlushing = false;\n      }\n    },\n\n    /**\n     * Clear the buffer without flushing\n     * Use with caution - may cause data loss\n     */\n    clear(): void {\n      entries = [];\n    },\n\n    /**\n     * Start the periodic flush timer\n     * Flushes buffer at flushIntervalMs intervals\n     */\n    start(): void {\n      // Clear any existing timer\n      this.stop();\n\n      // Start new timer\n      timer = setInterval(() => {\n        this.flush();\n      }, fullConfig.flushIntervalMs);\n    },\n\n    /**\n     * Stop the periodic flush timer\n     * Optionally flushes remaining entries\n     */\n    stop(options?: { flushRemaining?: boolean }): void {\n      // Clear timer\n      if (timer) {\n        clearInterval(timer);\n        timer = null;\n      }\n\n      // Flush remaining entries by default (prevents data loss on session end)\n      if (options?.flushRemaining !== false) {\n        this.flush();\n      }\n    },\n\n    /**\n     * Get current buffer size\n     * @returns Number of entries in buffer\n     */\n    size(): number {\n      return entries.length;\n    },\n\n    /**\n     * Get time since last flush\n     * @returns Milliseconds since last flush\n     */\n    getLastFlushTime(): number {\n      return Date.now() - lastFlush;\n    },\n\n    /**\n     * Check if buffer is currently flushing\n     * @returns True if flush is in progress\n     */\n    isFlushInProgress(): boolean {\n      return isFlushing;\n    },\n  };\n}\n\n/**\n * Factory function to create a configured event buffer\n * @param onFlush - Callback for flushed entries\n * @param options - Optional configuration overrides\n * @returns Configured EventBuffer instance\n * @deprecated Use createEventBuffer instead\n */\nexport function createBuffer(\n  onFlush: (entries: MemoryEntry[]) => void,\n  options?: Partial<Omit<BufferConfig, \"onFlush\">>\n): IEventBuffer {\n  return createEventBuffer({\n    ...options,\n    onFlush,\n  });\n}\n\n/**\n * @deprecated Use createEventBuffer instead. This export is kept for backward compatibility.\n * The EventBuffer class has been converted to a factory function to avoid ESM interop issues.\n */\nexport const EventBuffer = createEventBuffer;\n","/**\n * Privacy Filter Module\n *\n * Prevents sensitive data from being stored in mind.mv2.\n * Handles secret detection, file exclusion, and bash command sanitization.\n *\n * @module privacy/filter\n */\n\n/**\n * Patterns for detecting sensitive content in strings.\n * These patterns match common secret formats like passwords, API keys, tokens, etc.\n */\nexport const SENSITIVE_PATTERNS: RegExp[] = [\n  // Password patterns\n  /password\\s*[:=]\\s*\\S+/gi,\n  /[a-zA-Z0-9_]*password[a-zA-Z0-9_]*\\s*[=:]\\s*[\"']?[^\"'\\s]+[\"']?/gi,\n  \n  // API key patterns\n  /api[_-]?key\\s*[:=]\\s*\\S+/gi,\n  \n  // Token patterns\n  /token\\s*[:=]\\s*\\S+/gi,\n  \n  // Secret patterns\n  /secret\\s*[:=]\\s*\\S+/gi,\n  \n  // Private key patterns\n  /private[_-]?key\\s*[:=]\\s*\\S+/gi,\n  /-----BEGIN (RSA|EC|DSA|OPENSSH) PRIVATE KEY-----/,\n  \n  // URL with embedded credentials\n  /:\\/\\/[^\\s:@]+:[^\\s:@]+@/g,\n];\n\n/**\n * Patterns for excluding files from capture based on path.\n * These patterns match paths that should never be stored.\n */\nexport const EXCLUDED_PATH_PATTERNS: RegExp[] = [\n  // .env files and variations (.env.local, .env.development.local, etc.)\n  // Matches .env at root or in any directory\n  /(^|\\/)\\.env$/,\n  /(^|\\/)\\.env\\.[\\w.-]+$/,\n  \n  // Git directory\n  /\\.git\\//,\n  \n  // Certificate and key files\n  /\\.(key|pem|p12|pfx)$/i,\n  \n  // Files with sensitive names in path\n  /secret/i,\n  /password/i,\n  /credential/i,\n  /token/i,\n  /private/i,\n];\n\n/**\n * Patterns for detecting sensitive bash commands that should be redacted.\n */\nexport const SENSITIVE_BASH_PATTERNS: RegExp[] = [\n  // curl with user credentials\n  /curl.*-u\\s/,\n  /curl.*--user\\s/,\n  \n  // ssh with password\n  /ssh.*-p\\s/,\n  \n  // mysql with password\n  /mysql.*-p\\s/,\n  /mysql.*--password/,\n  \n  // postgres with password\n  /psql.*-W\\s/,\n  /psql.*--password/,\n];\n\n/**\n * Replacement string for redacted sensitive content.\n */\nexport const REDACTED_STRING = \"[REDACTED]\";\n\n/**\n * Replacement string for redacted bash commands.\n */\nexport const REDACTED_COMMAND_STRING = \"[REDACTED BASH COMMAND]\";\n\n/**\n * Sanitizes content by redacting sensitive patterns.\n *\n * @param content - The content to sanitize\n * @returns Sanitized content with sensitive data replaced by [REDACTED]\n */\nexport function sanitizeContent(content: string): string {\n  if (!content || typeof content !== \"string\") {\n    return \"\";\n  }\n\n  let sanitized = content;\n  \n  for (const pattern of SENSITIVE_PATTERNS) {\n    sanitized = sanitized.replace(pattern, (match) => {\n      // For patterns that include the key name (like \"password: \"), preserve the key\n      const colonIndex = match.indexOf(\":\");\n      const equalsIndex = match.indexOf(\"=\");\n      \n      if (colonIndex > 0 && (equalsIndex === -1 || colonIndex < equalsIndex)) {\n        return match.substring(0, colonIndex + 1) + \" \" + REDACTED_STRING;\n      }\n      \n      if (equalsIndex > 0 && (colonIndex === -1 || equalsIndex < colonIndex)) {\n        return match.substring(0, equalsIndex + 1) + REDACTED_STRING;\n      }\n      \n      // For URL patterns, replace the credentials portion\n      if (match.includes(\"://\")) {\n        return match.replace(/:\\/\\/[^:]+:[^@]+@/, \"://\" + REDACTED_STRING + \"@\");\n      }\n      \n      return REDACTED_STRING;\n    });\n  }\n  \n  return sanitized;\n}\n\n/**\n * Determines whether a file should be captured based on its path.\n *\n * @param filePath - The file path to check\n * @returns true if the file should be captured, false if it should be excluded\n */\nexport function shouldCaptureFile(filePath: string): boolean {\n  if (!filePath || typeof filePath !== \"string\") {\n    return false;\n  }\n\n  // Normalize path separators (handle both Windows and Unix)\n  const normalizedPath = filePath.replace(/\\\\/g, \"/\");\n  \n  for (const pattern of EXCLUDED_PATH_PATTERNS) {\n    if (pattern.test(normalizedPath)) {\n      return false;\n    }\n  }\n  \n  return true;\n}\n\n/**\n * Sanitizes a bash command, redacting it if it contains sensitive patterns.\n *\n * @param command - The bash command to sanitize\n * @returns The sanitized command, [REDACTED BASH COMMAND] if sensitive, or null if empty\n */\nexport function sanitizeBashCommand(command: string): string | null {\n  if (!command || typeof command !== \"string\") {\n    return null;\n  }\n\n  const trimmedCommand = command.trim();\n  \n  if (trimmedCommand.length === 0) {\n    return null;\n  }\n\n  // Check if command matches any sensitive patterns\n  for (const pattern of SENSITIVE_PATTERNS) {\n    if (pattern.test(trimmedCommand)) {\n      return REDACTED_COMMAND_STRING;\n    }\n  }\n\n  // Check if command matches sensitive bash patterns\n  for (const pattern of SENSITIVE_BASH_PATTERNS) {\n    if (pattern.test(trimmedCommand)) {\n      return REDACTED_COMMAND_STRING;\n    }\n  }\n\n  return trimmedCommand;\n}\n\n/**\n * Quickly checks if content contains sensitive patterns.\n * Useful for early exit optimization.\n *\n * @param content - The content to check\n * @returns true if content contains sensitive patterns\n */\nexport function isSensitiveContent(content: string): boolean {\n  if (!content || typeof content !== \"string\") {\n    return false;\n  }\n\n  for (const pattern of SENSITIVE_PATTERNS) {\n    if (pattern.test(content)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n * Sanitizes an object recursively, redacting sensitive values.\n * Preserves object structure but replaces sensitive string values.\n *\n * @param obj - The object to sanitize\n * @returns A new object with sensitive values redacted\n */\nexport function sanitizeObject<T>(obj: T): T {\n  if (typeof obj === \"string\") {\n    return sanitizeContent(obj) as unknown as T;\n  }\n  \n  if (Array.isArray(obj)) {\n    return obj.map(item => sanitizeObject(item)) as unknown as T;\n  }\n  \n  if (obj !== null && typeof obj === \"object\") {\n    const sanitized: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(obj)) {\n      // Check if the key itself is sensitive\n      const lowerKey = key.toLowerCase();\n      if (lowerKey.includes(\"password\") || \n          lowerKey.includes(\"secret\") || \n          lowerKey.includes(\"token\") || \n          lowerKey.includes(\"key\") ||\n          lowerKey.includes(\"credential\")) {\n        sanitized[key] = REDACTED_STRING;\n      } else {\n        sanitized[key] = sanitizeObject(value);\n      }\n    }\n    return sanitized as T;\n  }\n  \n  return obj;\n}\n\n/**\n * Gets a list of exclusion reasons for a file path.\n * Useful for debugging why a file was excluded.\n *\n * @param filePath - The file path to check\n * @returns Array of pattern descriptions that matched, or empty array if file should be captured\n */\nexport function getExclusionReasons(filePath: string): string[] {\n  if (!filePath || typeof filePath !== \"string\") {\n    return [\"Invalid path\"];\n  }\n\n  const normalizedPath = filePath.replace(/\\\\/g, \"/\");\n  const reasons: string[] = [];\n  \n  const patternDescriptions: [RegExp, string][] = [\n    [/\\.env$/, \".env file\"],\n    [/\\.env\\.\\w+$/, \".env variant file\"],\n    [/\\.git\\//, \"Git directory file\"],\n    [/\\.(key|pem|p12|pfx)$/i, \"Certificate/key file\"],\n    [/secret/i, \"Path contains 'secret'\"],\n    [/password/i, \"Path contains 'password'\"],\n    [/credential/i, \"Path contains 'credential'\"],\n    [/token/i, \"Path contains 'token'\"],\n    [/private/i, \"Path contains 'private'\"],\n  ];\n  \n  for (const [pattern, description] of patternDescriptions) {\n    if (pattern.test(normalizedPath)) {\n      reasons.push(description);\n    }\n  }\n  \n  return reasons;\n}\n","/**\n * Tool Event Capture Module\n *\n * Captures tool.execute.after events and converts them to MemoryEntry objects.\n * Integrates with EventBuffer for batched writes and PrivacyFilter for data sanitization.\n *\n * @module events/tool-capture\n */\n\nimport type { MemoryEntry } from \"../storage/storage-interface.js\";\nimport type { IEventBuffer } from \"./buffer.js\";\nimport { sanitizeContent, sanitizeBashCommand } from \"../privacy/filter.js\";\nimport type { ObservationType } from \"../types.js\";\n\n/**\n * Input data from tool.execute.after event\n */\nexport interface ToolExecuteInput {\n  /** Tool name (e.g., \"read\", \"write\", \"bash\") */\n  tool: string;\n  /** Session identifier */\n  sessionID: string;\n  /** Unique call identifier */\n  callID: string;\n  /** Tool arguments */\n  args?: Record<string, unknown>;\n}\n\n/**\n * Maps tool names to observation types.\n * Different tools represent different kinds of cognitive activity:\n * - discovery: Information gathering (search, read, glob)\n * - solution: Problem solving (write, bash for setup)\n * - refactor: Code changes (edit)\n * - pattern: Default/fallback\n *\n * @param tool - The tool name from Opencode\n * @returns The corresponding ObservationType\n */\nexport function determineObservationType(tool: string): ObservationType {\n  const typeMap: Record<string, ObservationType> = {\n    search: \"discovery\",\n    read: \"discovery\",\n    glob: \"discovery\",\n    ask: \"discovery\",\n    write: \"solution\",\n    bash: \"solution\",\n    edit: \"refactor\",\n  };\n\n  return typeMap[tool] || \"pattern\";\n}\n\n/**\n * Extracts file paths from tool arguments.\n * Different tools have different argument patterns for file references.\n *\n * @param args - Tool arguments from the event\n * @returns Array of file paths found in arguments\n */\nexport function extractFilesFromArgs(args: Record<string, unknown>): string[] {\n  const files: string[] = [];\n\n  if (!args || typeof args !== \"object\") {\n    return files;\n  }\n\n  // Common file path argument names\n  const filePathKeys = [\"filePath\", \"path\", \"file\"];\n  for (const key of filePathKeys) {\n    const value = args[key];\n    if (typeof value === \"string\" && value.length > 0) {\n      files.push(value);\n    }\n  }\n\n  // Handle array of files\n  if (Array.isArray(args.files)) {\n    for (const file of args.files) {\n      if (typeof file === \"string\" && file.length > 0) {\n        files.push(file);\n      }\n    }\n  }\n\n  // For edit tool, try to infer file from context\n  if (args.oldString || args.newString) {\n    // If we have filePath already, it's already captured above\n    // If not, this might be an edit without explicit file path\n    // which is unusual but we handle gracefully\n    if (files.length === 0 && args.filePath) {\n      files.push(String(args.filePath));\n    }\n  }\n\n  // Filter out non-string values and duplicates\n  return Array.from(new Set(files.filter((f) => typeof f === \"string\" && f.length > 0)));\n}\n\n/**\n * Creates a human-readable summary of tool execution.\n * Includes relevant arguments while respecting privacy.\n *\n * @param tool - The tool name\n * @param args - Tool arguments\n * @returns Formatted description of the tool execution\n */\nexport function formatToolContent(\n  tool: string,\n  args: Record<string, unknown> | undefined\n): string {\n  const safeArgs = args || {};\n\n  switch (tool) {\n    case \"read\": {\n      const filePath = safeArgs.filePath || safeArgs.path || safeArgs.file;\n      if (typeof filePath === \"string\") {\n        return `Read file: ${filePath}`;\n      }\n      return \"Read file\";\n    }\n\n    case \"write\": {\n      const filePath = safeArgs.filePath || safeArgs.path || safeArgs.file;\n      if (typeof filePath === \"string\") {\n        return `Wrote file: ${filePath}`;\n      }\n      return \"Wrote file\";\n    }\n\n    case \"edit\": {\n      const filePath = safeArgs.filePath || safeArgs.path || safeArgs.file;\n      if (typeof filePath === \"string\") {\n        return `Edited file: ${filePath}`;\n      }\n      return \"Edited file\";\n    }\n\n    case \"bash\": {\n      const command = safeArgs.command;\n      if (typeof command === \"string\") {\n        return `Executed: ${command}`;\n      }\n      return \"Executed bash command\";\n    }\n\n    case \"search\": {\n      const pattern = safeArgs.pattern || safeArgs.query;\n      if (typeof pattern === \"string\") {\n        return `Searched: ${pattern}`;\n      }\n      return \"Performed search\";\n    }\n\n    case \"glob\": {\n      const pattern = safeArgs.pattern;\n      if (typeof pattern === \"string\") {\n        return `Glob search: ${pattern}`;\n      }\n      return \"Performed glob search\";\n    }\n\n    case \"ask\": {\n      const question = safeArgs.question;\n      if (typeof question === \"string\") {\n        // Truncate very long questions\n        const truncated =\n          question.length > 100 ? question.substring(0, 100) + \"...\" : question;\n        return `Asked: ${truncated}`;\n      }\n      return \"Asked question\";\n    }\n\n    default:\n      return `Used ${tool} tool`;\n  }\n}\n\n/**\n * Captures a tool execution event and adds it to the event buffer.\n * This is the main entry point for tool event capture.\n *\n * Features:\n * - Determines observation type from tool name\n * - Extracts file references from arguments\n * - Sanitizes content using privacy filters\n * - Creates MemoryEntry for storage\n * - Adds to buffer for batched writes\n *\n * @param input - Tool execution input from Opencode\n * @param buffer - EventBuffer for batched writes\n * @throws Never - all errors are caught and logged\n */\nexport function captureToolExecution(\n  input: ToolExecuteInput,\n  buffer: IEventBuffer\n): void {\n  try {\n    // Determine observation type\n    const observationType = determineObservationType(input.tool);\n\n    // Format content based on tool type\n    const formattedContent = formatToolContent(input.tool, input.args);\n\n    // Apply privacy filtering based on tool type\n    let sanitizedContent: string;\n    if (input.tool === \"bash\" && input.args?.command) {\n      const sanitizedCommand = sanitizeBashCommand(String(input.args.command));\n      if (sanitizedCommand === null) {\n        sanitizedContent = \"[REDACTED BASH COMMAND]\";\n      } else if (sanitizedCommand === \"[REDACTED BASH COMMAND]\") {\n        // Already redacted by sanitizeBashCommand\n        sanitizedContent = sanitizedCommand;\n      } else {\n        sanitizedContent = `Executed: ${sanitizedCommand}`;\n      }\n    } else {\n      sanitizedContent = sanitizeContent(formattedContent);\n    }\n\n    // Extract file references\n    const files = extractFilesFromArgs(input.args || {});\n\n    // Create memory entry\n    const entry: MemoryEntry = {\n      id: input.callID || crypto.randomUUID(),\n      type: observationType,\n      content: sanitizedContent,\n      createdAt: Date.now(),\n      metadata: {\n        sessionId: input.sessionID,\n        tool: input.tool,\n        summary: `${input.tool} executed`,\n        files: files.length > 0 ? files : undefined,\n      },\n    };\n\n    // Add to buffer for batched write\n    buffer.add(entry);\n\n    // Debug logging would happen in caller (plugin.ts)\n  } catch (error) {\n    // Never throw - graceful degradation\n    console.error(\n      \"[ToolCapture] Failed to capture tool execution:\",\n      error instanceof Error ? error.message : String(error)\n    );\n    // Continue without crashing Opencode\n  }\n}\n","/**\n * File Capture Module\n *\n * Captures file edit events with privacy filtering.\n * Excludes sensitive files like .env, secrets, certificates.\n *\n * @module events/file-capture\n */\n\nimport type { MemoryEntry } from \"../storage/storage-interface.js\";\nimport type { IEventBuffer } from \"./buffer.js\";\nimport { shouldCaptureFile } from \"../privacy/filter.js\";\n\n/**\n * Input for file edit capture\n */\nexport interface FileEditInput {\n  /** Path of the file that was edited */\n  filePath: string;\n}\n\n/**\n * Captures a file edit event to the event buffer.\n *\n * Checks if the file should be captured using privacy filtering,\n * then creates a MemoryEntry and adds it to the buffer.\n *\n * @param input - File edit input containing filePath\n * @param buffer - Event buffer to add the entry to\n * @param sessionId - Current session ID for metadata\n * @returns true if captured, false if skipped due to exclusion\n */\nexport function captureFileEdit(\n  input: FileEditInput,\n  buffer: IEventBuffer,\n  sessionId: string\n): boolean {\n  try {\n    // Check if file should be captured (privacy filtering)\n    if (!shouldCaptureFile(input.filePath)) {\n      return false; // Silently skip - no need to log for privacy\n    }\n\n    // Create memory entry\n    const entry: MemoryEntry = {\n      id: crypto.randomUUID(),\n      type: \"refactor\",\n      content: `File modified: ${input.filePath}`,\n      createdAt: Date.now(),\n      metadata: {\n        sessionId,\n        summary: `Edited ${input.filePath.split(\"/\").pop() || input.filePath}`,\n        files: [input.filePath],\n      },\n    };\n\n    // Add to buffer\n    buffer.add(entry);\n\n    return true;\n  } catch (error) {\n    // Silent error handling - don't crash the plugin\n    console.error(\n      \"[FileCapture] Failed to capture file edit:\",\n      error instanceof Error ? error.message : String(error)\n    );\n    return false;\n  }\n}\n","/**\n * Error Capture Module\n *\n * Captures session error events for debugging.\n * Filters sensitive error messages to prevent secrets from being stored.\n *\n * @module events/error-capture\n */\n\nimport type { MemoryEntry } from \"../storage/storage-interface.js\";\nimport type { IEventBuffer } from \"./buffer.js\";\nimport { isSensitiveContent } from \"../privacy/filter.js\";\n\n/**\n * Captures a session error to the event buffer.\n *\n * Checks if the error message contains sensitive patterns,\n * then creates a MemoryEntry and adds it to the buffer.\n *\n * Note: This captures plugin-level errors, not tool errors\n * (tool errors are handled in tool-capture.ts).\n *\n * @param error - The error to capture\n * @param buffer - Event buffer to add the entry to\n * @param sessionId - Current session ID for metadata\n */\nexport function captureSessionError(\n  error: Error,\n  buffer: IEventBuffer,\n  sessionId: string\n): void {\n  try {\n    // Skip if error message contains sensitive content\n    if (isSensitiveContent(error.message)) {\n      // Create sanitized entry without the sensitive message\n      const entry: MemoryEntry = {\n        id: crypto.randomUUID(),\n        type: \"problem\",\n        content: \"Session error: [REDACTED - contains sensitive data]\",\n        createdAt: Date.now(),\n        metadata: {\n          sessionId,\n          summary: `Error: ${error.name}`,\n          error: error.name,\n          redacted: true,\n        },\n      };\n\n      buffer.add(entry);\n      return;\n    }\n\n    // Create memory entry with error details\n    const entry: MemoryEntry = {\n      id: crypto.randomUUID(),\n      type: \"problem\",\n      content: `Session error: ${error.message}`,\n      createdAt: Date.now(),\n      metadata: {\n        sessionId,\n        summary: `Error: ${error.name}`,\n        error: error.name,\n      },\n    };\n\n    // Add to buffer\n    buffer.add(entry);\n  } catch {\n    // Silent fail - don't create infinite error loop\n    // If capturing the error fails, we just move on\n  }\n}\n","/**\n * Opencode Brain Plugin Implementation\n *\n * Core plugin logic using @opencode-ai/plugin SDK.\n * Handles session lifecycle, event capture, and storage management.\n *\n * **CRITICAL IMPLEMENTATION NOTES:**\n *\n * 1. **Context Destructuring Pattern**\n *    The plugin receives a context object with destructured params.\n *    CORRECT: `async ({ client, directory, worktree }) => { ... }`\n *\n * 2. **Synchronous Storage**\n *    bun:sqlite uses SYNCHRONOUS API. No await needed for storage.\n *    CORRECT: `const storage = createStorage({ filePath }); storage.write(...)`\n *    WRONG: `await createStorage(...)` or `await storage.write(...)`\n *\n * 3. **Event Handler Patterns**\n *    - Use `session.created` for session start\n *    - Use `session.deleted` for cleanup (NOT session.idle)\n *    - Use `tool.execute.after` for post-tool capture\n *    - Always handle errors gracefully (never throw)\n *\n * 4. **Error Handling**\n *    Never throw from event handlers - log and continue gracefully.\n *\n * @module plugin\n */\n\nimport type { Plugin } from \"@opencode-ai/plugin\";\nimport { createStorage } from \"./storage/sqlite-storage.js\";\nimport { loadConfig, getStoragePath } from \"./config.js\";\nimport { createEventBuffer } from \"./events/buffer.js\";\nimport type { MemoryEntry } from \"./storage/storage-interface.js\";\nimport { captureToolExecution } from \"./events/tool-capture.js\";\nimport { captureFileEdit } from \"./events/file-capture.js\";\nimport { captureSessionError } from \"./events/error-capture.js\";\n\n/**\n * Opencode Brain Plugin - Makes Opencode remember everything\n *\n * This plugin captures session context and makes it available across sessions.\n * It initializes storage on load, captures events during the session, and\n * cleans up gracefully when the session ends.\n *\n * @example\n * ```typescript\n * // In opencode.json:\n * {\n *   \"plugin\": [\"opencode-brain\"],\n *   \"opencode-brain\": {\n *     \"storagePath\": \".opencode/mind.mv2\",\n *     \"debug\": false\n *   }\n * }\n * ```\n */\nexport const OpencodeBrainPlugin: Plugin = async ({\n  client,\n  directory,\n  worktree,\n}) => {\n  // Load configuration with defaults (reads from file directly)\n  const config = loadConfig(directory);\n\n  // Determine storage path based on worktree (or directory as fallback)\n  const projectPath = worktree || directory;\n  const storagePath = getStoragePath(projectPath, config);\n\n  // Track current session ID for event metadata\n  let currentSessionId: string = \"unknown\";\n\n  // Initialize storage SYNCHRONOUSLY (bun:sqlite design)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let storage: any;\n  try {\n    storage = createStorage({ filePath: storagePath });\n  } catch (error) {\n    console.error(\n      \"[opencode-brain] Failed to initialize storage:\",\n      error instanceof Error ? error.message : String(error)\n    );\n    // Return minimal handlers so plugin doesn't crash Opencode\n    return {\n      onError: (err: Error) => {\n        console.error(\"[opencode-brain] Error:\", err.message);\n      },\n    };\n  }\n\n  // Create event buffer for batched writes\n  const eventBuffer = createEventBuffer({\n    maxSize: 50,\n    flushIntervalMs: 5000,\n    onFlush: (entries: MemoryEntry[]) => {\n      try {\n        // Write all buffered entries to storage synchronously\n        for (const entry of entries) {\n          storage.write(entry.id, entry);\n        }\n\n        if (config.debug) {\n          console.log(`[opencode-brain] Flushed ${entries.length} entries to storage`);\n        }\n      } catch (error) {\n        console.error(\n          \"[opencode-brain] Failed to flush entries:\",\n          error instanceof Error ? error.message : String(error)\n        );\n      }\n    },\n  });\n\n  // Start periodic flush timer\n  eventBuffer.start();\n\n  // Log initialization if debug mode enabled\n  if (config.debug) {\n    try {\n      const stats = storage.stats();\n      client.app.log({\n        body: {\n          service: \"opencode-brain\",\n          level: \"info\",\n          message: `[opencode-brain] Storage initialized at ${storagePath} (${stats.count} memories)`,\n        },\n      });\n    } catch {\n      client.app.log({\n        body: {\n          service: \"opencode-brain\",\n          level: \"info\",\n          message: `[opencode-brain] Storage initialized at ${storagePath}`,\n        },\n      });\n    }\n  }\n\n  // Return event handlers\n  return {\n    /**\n     * Session created - Called when a new Opencode session starts\n     *\n     * This is where context injection would happen in Phase 3.\n     * Currently tracks session ID for event metadata.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    \"session.created\": async ({ session }: { session: { id: string } }) => {\n      // Track session ID for all event capture\n      currentSessionId = session.id;\n\n      if (config.debug) {\n        client.app.log({\n          body: {\n            service: \"opencode-brain\",\n            level: \"info\",\n            message: `[opencode-brain] Session ${session.id} started`,\n          },\n        });\n      }\n\n      // Stub for Phase 3: Context injection\n      // TODO: Load relevant memories and inject into session context\n    },\n\n    /**\n     * Tool executed - Called after each tool execution\n     *\n     * Captures tool usage for memory using EventBuffer for batched writes.\n     * Privacy filtering is applied before storage.\n     */\n    \"tool.execute.after\": async (input: {\n      tool: string;\n      sessionID: string;\n      callID: string;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      args?: Record<string, any>;\n    }) => {\n      if (config.debug) {\n        console.log(\n          `[opencode-brain] Tool executed: ${input.tool}`,\n          input.args ? Object.keys(input.args) : \"no args\"\n        );\n      }\n\n      try {\n        // Capture tool execution with privacy filtering and buffering\n        captureToolExecution(\n          {\n            tool: input.tool,\n            sessionID: input.sessionID,\n            callID: input.callID,\n            args: input.args,\n          },\n          eventBuffer\n        );\n      } catch (error) {\n        // Never throw - graceful degradation\n        console.error(\n          \"[opencode-brain] Failed to capture tool execution:\",\n          error instanceof Error ? error.message : String(error)\n        );\n      }\n    },\n\n    /**\n     * File edited - Called when a file is modified\n     *\n     * Captures file changes for memory using EventBuffer for batched writes.\n     */\n    \"file.edited\": async (input: { filePath: string }) => {\n      if (config.debug) {\n        console.log(`[opencode-brain] File edited: ${input.filePath}`);\n      }\n\n      try {\n        // Capture file edit with privacy filtering and buffering\n        captureFileEdit(\n          {\n            filePath: input.filePath,\n          },\n          eventBuffer,\n          currentSessionId\n        );\n      } catch (error) {\n        // Never throw - graceful degradation\n        console.error(\n          \"[opencode-brain] Failed to capture file edit:\",\n          error instanceof Error ? error.message : String(error)\n        );\n      }\n    },\n\n    /**\n     * Session deleted - Called when session ends\n     *\n     * Use session.deleted (not session.idle) for cleanup.\n     * This is the reliable signal for session termination.\n     */\n    \"session.deleted\": async () => {\n      if (config.debug) {\n        console.log(\"[opencode-brain] Session ended, flushing buffer and closing storage\");\n      }\n\n      // Stop buffer and flush remaining entries\n      try {\n        eventBuffer.stop();\n      } catch (error) {\n        console.error(\n          \"[opencode-brain] Error stopping event buffer:\",\n          error instanceof Error ? error.message : String(error)\n        );\n        // Silent fail - don't crash Opencode during shutdown\n      }\n\n      // Close storage connection (SYNCHRONOUS)\n      try {\n        storage.close();\n      } catch (error) {\n        console.error(\n          \"[opencode-brain] Error closing storage:\",\n          error instanceof Error ? error.message : String(error)\n        );\n        // Silent fail - don't crash Opencode during shutdown\n      }\n    },\n\n    /**\n     * Error handler - Called when plugin encounters an error\n     *\n     * Captures error to memory for debugging, then logs and continues.\n     * Never throw from here - always graceful degradation.\n     */\n    onError: (error: Error) => {\n      console.error(\"[opencode-brain] Plugin error:\", error.message);\n\n      try {\n        captureSessionError(error, eventBuffer, currentSessionId);\n      } catch {\n        // Silent fail - don't create infinite error loop\n      }\n\n      // Don't re-throw - keep Opencode running\n    },\n  };\n};\n\n/**\n * Factory function for creating the plugin\n *\n * This is the primary export used by Opencode's plugin system.\n *\n * @example\n * ```typescript\n * import { createPlugin } from \"./plugin.js\";\n *\n * export default createPlugin();\n * ```\n */\nexport function createPlugin(): Plugin {\n  return OpencodeBrainPlugin;\n}\n","/**\n * Opencode Brain Plugin\n *\n * Memory persistence for Opencode - remember everything across sessions.\n *\n * @packageDocumentation\n */\n\nimport { OpencodeBrainPlugin } from \"./plugin.js\";\nimport type { PluginConfig } from \"./config.js\";\n\n// Privacy filtering functions\nexport {\n  sanitizeContent,\n  shouldCaptureFile,\n  sanitizeBashCommand,\n  isSensitiveContent,\n  sanitizeObject,\n  getExclusionReasons,\n} from \"./privacy/filter.js\";\n\n// Event capture modules\nexport { EventBuffer, createBuffer } from \"./events/buffer.js\";\nexport { captureToolExecution } from \"./events/tool-capture.js\";\nexport { captureFileEdit } from \"./events/file-capture.js\";\nexport { captureSessionError } from \"./events/error-capture.js\";\n\nexport { OpencodeBrainPlugin };\nexport type { PluginConfig };\nexport default OpencodeBrainPlugin;\n"],"mappings":"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","names":["entry"]}