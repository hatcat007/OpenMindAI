{"version":3,"sources":["../src/storage/sqlite-storage.ts","../src/config.ts","../src/plugin.ts","../src/index.ts"],"sourcesContent":["/**\n * Bun SQLite Storage Implementation\n *\n * Bun-compatible storage layer using bun:sqlite.\n * SYNCHRONOUS API - bun:sqlite returns values directly, not Promises.\n *\n * Features:\n * - WAL mode for concurrent access (no additional locking needed)\n * - FTS5 full-text search with macOS LIKE fallback\n * - Bun-compatible synchronous API\n * - Silent error handling (never crashes the plugin)\n */\n\nimport { Database } from \"bun:sqlite\";\nimport type {\n  StorageInterface,\n  StorageOptions,\n  StorageStats,\n  MemoryEntry,\n  MemoryMetadata,\n} from \"./storage-interface.js\";\nimport type { ObservationType } from \"../types.js\";\n\n/**\n * SQLite-based storage implementation for Bun runtime\n *\n * All methods are SYNCHRONOUS - bun:sqlite uses synchronous API.\n */\nexport class BrainStorage implements StorageInterface {\n  private db: Database;\n  private filePath: string;\n  private fts5Available: boolean;\n\n  /**\n   * Create a new storage instance\n   * @param filePath - Path to SQLite database file\n   */\n  constructor(filePath: string) {\n    this.filePath = filePath;\n\n    // Open database with creation enabled\n    this.db = new Database(filePath, { create: true });\n\n    // Enable WAL mode for concurrent access\n    this.db.run(\"PRAGMA journal_mode = WAL\");\n    this.db.run(\"PRAGMA busy_timeout = 5000\");\n\n    // Check FTS5 availability\n    this.fts5Available = this.checkFTS5Availability();\n\n    // Initialize schema\n    this.initializeSchema();\n  }\n\n  /**\n   * Check if FTS5 is available (not available on macOS by default)\n   */\n  private checkFTS5Availability(): boolean {\n    try {\n      // Try to create a test FTS5 table\n      this.db.run(\"CREATE VIRTUAL TABLE IF NOT EXISTS _fts5_test USING fts5(x)\");\n      this.db.run(\"DROP TABLE IF EXISTS _fts5_test\");\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Initialize database schema\n   */\n  private initializeSchema(): void {\n    // Main memories table\n    this.db.run(`\n      CREATE TABLE IF NOT EXISTS memories (\n        id TEXT PRIMARY KEY,\n        type TEXT NOT NULL,\n        content TEXT NOT NULL,\n        metadata TEXT NOT NULL,\n        created_at INTEGER NOT NULL,\n        session_id TEXT\n      )\n    `);\n\n    // Indices for efficient querying\n    this.db.run(`\n      CREATE INDEX IF NOT EXISTS idx_memories_type ON memories(type)\n    `);\n    this.db.run(`\n      CREATE INDEX IF NOT EXISTS idx_memories_created_at ON memories(created_at)\n    `);\n    this.db.run(`\n      CREATE INDEX IF NOT EXISTS idx_memories_session ON memories(session_id)\n    `);\n\n    // FTS5 virtual table for full-text search (if available)\n    if (this.fts5Available) {\n      this.db.run(`\n        CREATE VIRTUAL TABLE IF NOT EXISTS memories_fts USING fts5(\n          content,\n          content_rowid='rowid'\n        )\n      `);\n    }\n  }\n\n  /**\n   * Store a memory entry (SYNCHRONOUS)\n   * @param id - Unique identifier\n   * @param data - Memory entry data\n   */\n  write(id: string, data: MemoryEntry): void {\n    try {\n      const stmt = this.db.prepare(`\n        INSERT OR REPLACE INTO memories\n        (id, type, content, metadata, created_at, session_id)\n        VALUES (?, ?, ?, ?, ?, ?)\n      `);\n\n      stmt.run(\n        id,\n        data.type,\n        data.content,\n        JSON.stringify(data.metadata),\n        data.createdAt,\n        data.metadata?.sessionId || null\n      );\n      stmt.finalize();\n\n      // Update FTS5 index if available\n      if (this.fts5Available) {\n        try {\n          const rowId = this.db\n            .query(\"SELECT rowid FROM memories WHERE id = ?\")\n            .get(id) as { rowid: number } | null;\n\n          if (rowId) {\n            const ftsStmt = this.db.prepare(`\n              INSERT OR REPLACE INTO memories_fts (rowid, content)\n              VALUES (?, ?)\n            `);\n            ftsStmt.run(rowId.rowid, data.content);\n            ftsStmt.finalize();\n          }\n        } catch (ftsError) {\n          // Silent fail for FTS5 errors\n          console.error(\"FTS5 index update failed:\", ftsError);\n        }\n      }\n    } catch (error) {\n      // Silent fail - log but don't crash\n      console.error(\"Storage write failed:\", error);\n    }\n  }\n\n  /**\n   * Retrieve a memory entry by ID (SYNCHRONOUS)\n   * @param id - Unique identifier\n   * @returns Memory entry or null if not found\n   */\n  read(id: string): MemoryEntry | null {\n    try {\n      const row = this.db\n        .query(\"SELECT * FROM memories WHERE id = ?\")\n        .get(id) as DatabaseRow | null;\n\n      if (!row) {\n        return null;\n      }\n\n      return this.rowToMemoryEntry(row);\n    } catch (error) {\n      console.error(\"Storage read failed:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Search memory entries (SYNCHRONOUS)\n   * @param query - Search query string\n   * @param limit - Maximum results (default: 10)\n   * @returns Array of matching entries\n   */\n  search(query: string, limit = 10): MemoryEntry[] {\n    try {\n      if (this.fts5Available) {\n        return this.searchFTS5(query, limit);\n      } else {\n        return this.searchLIKE(query, limit);\n      }\n    } catch (error) {\n      console.error(\"Storage search failed:\", error);\n      return [];\n    }\n  }\n\n  /**\n   * Search using FTS5 (Linux/Windows)\n   */\n  private searchFTS5(query: string, limit: number): MemoryEntry[] {\n    try {\n      const stmt = this.db.prepare(`\n        SELECT m.* FROM memories m\n        JOIN memories_fts fts ON fts.rowid = m.rowid\n        WHERE fts MATCH ?\n        ORDER BY rank\n        LIMIT ?\n      `);\n\n      const rows = stmt.all(query, limit) as DatabaseRow[];\n      stmt.finalize();\n\n      return rows.map((row) => this.rowToMemoryEntry(row));\n    } catch {\n      // Fallback to LIKE if FTS5 fails\n      return this.searchLIKE(query, limit);\n    }\n  }\n\n  /**\n   * Search using LIKE (macOS fallback)\n   */\n  private searchLIKE(query: string, limit: number): MemoryEntry[] {\n    const likePattern = `%${query.replace(/%/g, \"\\\\%\").replace(/_/g, \"\\\\_\")}%`;\n\n    const stmt = this.db.prepare(`\n      SELECT * FROM memories\n      WHERE content LIKE ?\n      ORDER BY created_at DESC\n      LIMIT ?\n    `);\n\n    const rows = stmt.all(likePattern, limit) as DatabaseRow[];\n    stmt.finalize();\n\n    return rows.map((row) => this.rowToMemoryEntry(row));\n  }\n\n  /**\n   * Get storage statistics (SYNCHRONOUS)\n   * @returns Storage statistics\n   */\n  stats(): StorageStats {\n    try {\n      const countRow = this.db\n        .query(\"SELECT COUNT(*) as count FROM memories\")\n        .get() as { count: number } | null;\n\n      const timeRange = this.db\n        .query(\"SELECT MIN(created_at) as oldest, MAX(created_at) as newest FROM memories\")\n        .get() as { oldest: number | null; newest: number | null } | null;\n\n      const typeCounts = this.db\n        .query(\"SELECT type, COUNT(*) as count FROM memories GROUP BY type\")\n        .all() as { type: string; count: number }[];\n\n      const byType: Record<string, number> = {};\n      for (const { type, count } of typeCounts) {\n        byType[type] = count;\n      }\n\n      // Estimate size based on SQLite page count\n      let sizeBytes = 0;\n      try {\n        const pageCount = this.db\n          .query(\"PRAGMA page_count\")\n          .get() as { \"page_count\": number } | null;\n        const pageSize = this.db\n          .query(\"PRAGMA page_size\")\n          .get() as { \"page_size\": number } | null;\n\n        if (pageCount && pageSize) {\n          sizeBytes = pageCount[\"page_count\"] * pageSize[\"page_size\"];\n        }\n      } catch {\n        // Size estimation is not critical\n      }\n\n      return {\n        count: countRow?.count || 0,\n        sizeBytes,\n        oldestEntry: timeRange?.oldest || undefined,\n        newestEntry: timeRange?.newest || undefined,\n        byType,\n      };\n    } catch (error) {\n      console.error(\"Storage stats failed:\", error);\n      return {\n        count: 0,\n        sizeBytes: 0,\n        byType: {},\n      };\n    }\n  }\n\n  /**\n   * Close storage connection (SYNCHRONOUS)\n   */\n  close(): void {\n    try {\n      this.db.close();\n    } catch (error) {\n      console.error(\"Storage close failed:\", error);\n    }\n  }\n\n  /**\n   * Convert database row to MemoryEntry\n   */\n  private rowToMemoryEntry(row: DatabaseRow): MemoryEntry {\n    let metadata: MemoryMetadata;\n    try {\n      metadata = JSON.parse(row.metadata) as MemoryMetadata;\n    } catch {\n      metadata = {};\n    }\n\n    return {\n      id: row.id,\n      type: row.type as ObservationType,\n      content: row.content,\n      createdAt: row.created_at,\n      metadata: {\n        ...metadata,\n        sessionId: row.session_id || metadata.sessionId,\n      },\n    };\n  }\n\n  /**\n   * Check if WAL mode is enabled\n   */\n  isWALModeEnabled(): boolean {\n    try {\n      const result = this.db\n        .query(\"PRAGMA journal_mode\")\n        .get() as { journal_mode: string } | null;\n      return result?.journal_mode === \"wal\";\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Check if FTS5 is available\n   */\n  isFTS5Available(): boolean {\n    return this.fts5Available;\n  }\n\n  /**\n   * Get the storage file path\n   */\n  getFilePath(): string {\n    return this.filePath;\n  }\n}\n\n/**\n * Database row type\n */\ninterface DatabaseRow {\n  id: string;\n  type: string;\n  content: string;\n  metadata: string;\n  created_at: number;\n  session_id: string | null;\n  rowid?: number;\n}\n\n/**\n * Factory function to create storage instance\n * @param options - Storage options\n * @returns StorageInterface instance\n */\nexport function createStorage(options: StorageOptions): StorageInterface {\n  return new BrainStorage(options.filePath);\n}\n","/**\n * Plugin Configuration Module\n *\n * Configuration management for the Opencode Brain plugin.\n * Handles user config loading, defaults merging, and path resolution.\n *\n * @module config\n */\n\nimport { join } from \"node:path\";\nimport { mkdirSync } from \"node:fs\";\n\n/**\n * Plugin configuration options\n */\nexport interface PluginConfig {\n  /** Storage file path (relative to worktree or absolute) */\n  storagePath?: string;\n  /** Auto-initialize storage on first run (default: true) */\n  autoInitialize?: boolean;\n  /** Enable debug logging (default: false) */\n  debug?: boolean;\n}\n\n/**\n * Plugin context passed by Opencode\n */\nexport interface PluginContext {\n  /** Project directory */\n  directory: string;\n  /** Worktree path (if in a git repo) */\n  worktree?: string;\n  /** Plugin-specific config from opencode.json */\n  config?: Record<string, unknown>;\n}\n\n/**\n * Default configuration values\n */\nconst DEFAULT_CONFIG: Required<PluginConfig> = {\n  storagePath: \".opencode/mind.mv2\",\n  autoInitialize: true,\n  debug: false,\n};\n\n/**\n * Load plugin configuration with defaults\n *\n * Merges user-provided config with defaults. Uses this precedence:\n * 1. User-provided config from opencode.json (via ctx.config)\n * 2. Environment variables (OPENCODE_BRAIN_*)\n * 3. Hardcoded defaults\n *\n * @param ctx - Plugin context from Opencode\n * @returns Merged configuration with all values populated\n *\n * @example\n * ```typescript\n * const config = loadConfig({ directory: '/project', config: { debug: true } });\n * // config.debug === true (from user)\n * // config.autoInitialize === true (from defaults)\n * ```\n */\nexport function loadConfig(ctx: PluginContext): Required<PluginConfig> {\n  const userConfig = (ctx.config || {}) as PluginConfig;\n\n  // Environment variable overrides\n  const envConfig: Partial<PluginConfig> = {};\n\n  if (process.env.OPENCODE_BRAIN_STORAGE_PATH) {\n    envConfig.storagePath = process.env.OPENCODE_BRAIN_STORAGE_PATH;\n  }\n\n  if (process.env.OPENCODE_BRAIN_DEBUG) {\n    envConfig.debug = process.env.OPENCODE_BRAIN_DEBUG === \"true\";\n  }\n\n  if (process.env.OPENCODE_BRAIN_AUTO_INIT) {\n    envConfig.autoInitialize = process.env.OPENCODE_BRAIN_AUTO_INIT !== \"false\";\n  }\n\n  // Merge: defaults < user config < environment\n  return {\n    storagePath: envConfig.storagePath ?? userConfig.storagePath ?? DEFAULT_CONFIG.storagePath,\n    autoInitialize: envConfig.autoInitialize ?? userConfig.autoInitialize ?? DEFAULT_CONFIG.autoInitialize,\n    debug: envConfig.debug ?? userConfig.debug ?? DEFAULT_CONFIG.debug,\n  };\n}\n\n/**\n * Resolve storage path to absolute path\n *\n * If relative path provided, resolves relative to worktree or directory.\n * Ensures parent directory exists.\n *\n * @param worktree - Project worktree path (from Opencode)\n * @param config - Plugin configuration\n * @returns Absolute path to storage file\n *\n * @example\n * ```typescript\n * const path = getStoragePath('/my/project', { storagePath: '.opencode/mind.mv2' });\n * // Returns: '/my/project/.opencode/mind.mv2'\n * ```\n */\nexport function getStoragePath(worktree: string, config: PluginConfig): string {\n  const storagePath = config.storagePath || DEFAULT_CONFIG.storagePath;\n\n  // If already absolute, use as-is\n  if (storagePath.startsWith(\"/\")) {\n    ensureDirectory(storagePath);\n    return storagePath;\n  }\n\n  // Resolve relative to worktree\n  const absolutePath = join(worktree, storagePath);\n  ensureDirectory(absolutePath);\n\n  return absolutePath;\n}\n\n/**\n * Ensure parent directory exists for a file path\n *\n * Creates parent directories recursively if missing.\n * Silent fail if directory already exists or can't be created.\n *\n * @param filePath - Path to file (directories will be created)\n *\n * @example\n * ```typescript\n * ensureDirectory('/path/to/file.txt');\n * // Creates /path/to/ if it doesn't exist\n * ```\n */\nexport function ensureDirectory(filePath: string): void {\n  try {\n    const parentDir = filePath.includes(\"/\")\n      ? filePath.slice(0, filePath.lastIndexOf(\"/\"))\n      : \".\";\n\n    if (parentDir && parentDir !== \".\") {\n      mkdirSync(parentDir, { recursive: true });\n    }\n  } catch (error) {\n    // Silent fail - directory may already exist or be created by another process\n    // This is non-critical, the database creation will fail later if truly broken\n  }\n}\n","/**\n * Opencode Brain Plugin Implementation\n *\n * Core plugin logic using @opencode-ai/plugin SDK.\n * Handles session lifecycle, event capture, and storage management.\n *\n * **CRITICAL IMPLEMENTATION NOTES:**\n *\n * 1. **Context Destructuring Pattern**\n *    The plugin receives a context object with destructured params.\n *    CORRECT: `async ({ client, directory, worktree }) => { ... }`\n *\n * 2. **Synchronous Storage**\n *    bun:sqlite uses SYNCHRONOUS API. No await needed for storage.\n *    CORRECT: `const storage = createStorage({ filePath }); storage.write(...)`\n *    WRONG: `await createStorage(...)` or `await storage.write(...)`\n *\n * 3. **Event Handler Patterns**\n *    - Use `session.created` for session start\n *    - Use `session.deleted` for cleanup (NOT session.idle)\n *    - Use `tool.execute.after` for post-tool capture\n *    - Always handle errors gracefully (never throw)\n *\n * 4. **Error Handling**\n *    Never throw from event handlers - log and continue gracefully.\n *\n * @module plugin\n */\n\nimport type { Plugin } from \"@opencode-ai/plugin\";\nimport { createStorage } from \"./storage/sqlite-storage.js\";\nimport { loadConfig, getStoragePath } from \"./config.js\";\n\n/**\n * Opencode Brain Plugin - Makes Opencode remember everything\n *\n * This plugin captures session context and makes it available across sessions.\n * It initializes storage on load, captures events during the session, and\n * cleans up gracefully when the session ends.\n *\n * @example\n * ```typescript\n * // In opencode.json:\n * {\n *   \"plugin\": [\"opencode-brain\"],\n *   \"opencode-brain\": {\n *     \"storagePath\": \".opencode/mind.mv2\",\n *     \"debug\": false\n *   }\n * }\n * ```\n */\nexport const OpencodeBrainPlugin: Plugin = async ({\n  client,\n  directory,\n  worktree,\n}: {\n  client: {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    config?: Record<string, any>;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    app: { log: (data: any) => void };\n  };\n  directory: string;\n  worktree?: string;\n}) => {\n  // Load configuration with defaults\n  const pluginConfig = client.config?.[\"opencode-brain\"] || {};\n  const config = loadConfig({\n    directory,\n    worktree,\n    config: pluginConfig as Record<string, unknown>,\n  });\n\n  // Determine storage path based on worktree (or directory as fallback)\n  const projectPath = worktree || directory;\n  const storagePath = getStoragePath(projectPath, config);\n\n  // Initialize storage SYNCHRONOUSLY (bun:sqlite design)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let storage: any;\n  try {\n    storage = createStorage({ filePath: storagePath });\n  } catch (error) {\n    console.error(\n      \"[opencode-brain] Failed to initialize storage:\",\n      error instanceof Error ? error.message : String(error)\n    );\n    // Return minimal handlers so plugin doesn't crash Opencode\n    return {\n      onError: (err: Error) => {\n        console.error(\"[opencode-brain] Error:\", err.message);\n      },\n    };\n  }\n\n  // Log initialization if debug mode enabled\n  if (config.debug) {\n    try {\n      const stats = storage.stats();\n      client.app.log({\n        message: `[opencode-brain] Storage initialized at ${storagePath} (${stats.count} memories)`,\n      });\n    } catch {\n      client.app.log({\n        message: `[opencode-brain] Storage initialized at ${storagePath}`,\n      });\n    }\n  }\n\n  // Return event handlers\n  return {\n    /**\n     * Session created - Called when a new Opencode session starts\n     *\n     * This is where context injection would happen in Phase 3.\n     * Currently just logs initialization in debug mode.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    \"session.created\": async ({ session }: { session: { id: string } }) => {\n      if (config.debug) {\n        client.app.log({\n          message: `[opencode-brain] Session ${session.id} started`,\n        });\n      }\n\n      // Stub for Phase 3: Context injection\n      // TODO: Load relevant memories and inject into session context\n    },\n\n    /**\n     * Tool executed - Called after each tool execution\n     *\n     * Captures tool usage for memory. Stub for Phase 2 implementation.\n     * Currently just logs if debug mode is enabled.\n     */\n    \"tool.execute.after\": async (input: {\n      tool: string;\n      sessionID: string;\n      callID: string;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      args?: Record<string, any>;\n    }) => {\n      if (config.debug) {\n        console.log(\n          `[opencode-brain] Tool executed: ${input.tool}`,\n          input.args ? Object.keys(input.args) : \"no args\"\n        );\n      }\n\n      // Stub for Phase 2: Event capture\n      // TODO: Write memory entry for significant tool executions\n    },\n\n    /**\n     * File edited - Called when a file is modified\n     *\n     * Captures file changes for memory. Stub for Phase 2.\n     */\n    \"file.edited\": async (input: { filePath: string }) => {\n      if (config.debug) {\n        console.log(`[opencode-brain] File edited: ${input.filePath}`);\n      }\n\n      // Stub for Phase 2: File change capture\n      // TODO: Write memory entry for significant file edits\n    },\n\n    /**\n     * Session deleted - Called when session ends\n     *\n     * Use session.deleted (not session.idle) for cleanup.\n     * This is the reliable signal for session termination.\n     */\n    \"session.deleted\": async () => {\n      if (config.debug) {\n        console.log(\"[opencode-brain] Session ended, closing storage\");\n      }\n\n      // Close storage connection (SYNCHRONOUS)\n      try {\n        storage.close();\n      } catch (error) {\n        console.error(\n          \"[opencode-brain] Error closing storage:\",\n          error instanceof Error ? error.message : String(error)\n        );\n        // Silent fail - don't crash Opencode during shutdown\n      }\n    },\n\n    /**\n     * Error handler - Called when plugin encounters an error\n     *\n     * Never throw from here - log and continue gracefully.\n     */\n    onError: (error: Error) => {\n      console.error(\"[opencode-brain] Plugin error:\", error.message);\n      // Don't re-throw - keep Opencode running\n    },\n  };\n};\n\n/**\n * Factory function for creating the plugin\n *\n * This is the primary export used by Opencode's plugin system.\n *\n * @example\n * ```typescript\n * import { createPlugin } from \"./plugin.js\";\n *\n * export default createPlugin();\n * ```\n */\nexport function createPlugin(): Plugin {\n  return OpencodeBrainPlugin;\n}\n","/**\n * Opencode Brain Plugin\n *\n * Memory persistence for Opencode - remember everything across sessions.\n *\n * @packageDocumentation\n */\n\nimport { OpencodeBrainPlugin } from \"./plugin.js\";\nimport type { PluginConfig } from \"./config.js\";\n\nexport { OpencodeBrainPlugin };\nexport type { PluginConfig };\nexport default OpencodeBrainPlugin;\n"],"mappings":"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","names":[]}